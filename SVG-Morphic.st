LineSegment subclass: #SVGClosingLineSegment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!MatrixTransformMorph subclass: #SVGComponentMorph	instanceVariableNames: 'id style cachedComposedStyle'	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 10:37'!antialiasingLevel	"Answer the level of antialiasing to use when drawing"	^self composedStyle at: 'aa-level' ifAbsent: [3]! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 10:39'!antialiasingLevel: anInteger	"Set the level of antialiasing to use when drawing"	^self composedStyle at: 'aa-level' put: anInteger! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/31/2005 13:12'!composedFillStyle	"Answer the composed fill style."	|fill|	fill := self composedStyle at: 'fill'.	fill isGradientFill		ifFalse: [^fill].	fill := fill mappedTo: self.	^fill! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/8/2005 13:25'!composedFontFillStyle	"Answer the composed font fill style."	|fill|	fill := self composedStyle at: 'font-fill'ifAbsent: [self composedFillStyle].	^fill! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 10:42'!composedStyle	"Answer the composed style dictionary"	self cachedComposedStyle isNil		ifTrue: [self				cachedComposedStyle: (self context composedStyle copy					addAll: self style;					yourself)].	^self cachedComposedStyle! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2005 20:31'!context	"If our owner chain has an SVGCompositeMorph, answer it, otherwise answer the default context."	^(self ownerThatIsA: SVGCompositeMorph) ifNil: [self defaultContext]! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/12/2005 11:12'!createFromSVG: anElement	"Create a path from the svg path."	self		id: (anElement attributeAt: 'id');		transform: (self transformFromSVGElement: anElement);		setStyleFromSVG: anElement! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/28/2005 16:25'!defaultContext	"Answer nil for now.."	^nil! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/29/2005 19:27'!fillFromSVGSpec: svgColor	"Answer a balloon fill style/color for the given svg color spec."	(svgColor beginsWith: 'url')		ifTrue: [^self context getFill: (svgColor allButFirst: 5) allButLast].	(svgColor = 'none')		ifTrue: [^Color transparent].	^Color fromCSS2String: svgColor! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2005 20:33'!globalBoundingBox	"Answer the bounding box of the receiver with resepect to the top level."	^self userSpaceBoundingBoxWithRespectTo: self svgContext! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/31/2005 13:16'!globalTransform	"Answer the transform of the receiver with resepect to the top level."	^self transformFrom: self svgContext! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2005 22:24'!hasFill	"Answer whether there is a fill for the receiver."	^self composedFillStyle isTransparent not! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/29/2005 13:51'!initialize	"Initialize the receiver."	super initialize.	self 		style: Dictionary new! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 10:42'!invalidateComposedStyleCache	"Reset the style cache for the receiver."	self cachedComposedStyle: nil! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 09:53'!renderer	"Answer a the renderer for the receiver.."	^SVGRenderer default! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/14/2005 11:00'!setStyleFromSVG: anElement	"Set the dictionary of the style parameters from the element."	self style		addAll:  (self renderer styleIn: self fromSVGStyle: (self styleFromSVG: anElement))! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:42'!styleFromSVG: anElement	"Answer a dictionary of the style parameters from the element."	|svgStyle answer attrs|	answer := SVGPropertyDictionary withParent: self context.	attrs := anElement attributes.	svgStyle := anElement attributeAt: 'style'.	svgStyle isNil ifFalse: [		(svgStyle subStrings: ':;') pairsDo: [:name :value |			attrs				at: name				put: value]].	(attrs includesKey: 'font-family')		ifTrue: [answer at: 'font-family' put: (attrs at: 'font-family')].	(attrs includesKey: 'font-size')		ifTrue: [answer at: 'font-size' put: (attrs at: 'font-size') asSVGNumber].	(attrs includesKey: 'text-anchor')		ifTrue: [answer at: 'text-anchor' put: (attrs at:'text-anchor') asSymbol].	(attrs includesKey: 'opacity')		ifTrue: [answer at: 'opacity' put: (attrs at: 'opacity') asSVGNumberOrPercentage].	(attrs includesKey: 'fill')		ifTrue: [answer at: 'fill' put: (self fillFromSVGSpec: (attrs at:'fill'))].	(attrs includesKey: 'fill-opacity')		ifTrue: [answer at: 'fill-opacity' put: (attrs at: 'fill-opacity') asSVGNumberOrPercentage].	(attrs  includesKey: 'fill-rule')		ifTrue: [answer at: 'fill-rule' put: (attrs at: 'fill-rule') asSymbol].	(attrs  includesKey: 'stroke')		ifTrue: [answer at: 'stroke' put: (self fillFromSVGSpec: (attrs at:'stroke'))].	(attrs  includesKey: 'stroke-opacity')		ifTrue: [answer at: 'stroke-opacity' put: (attrs at: 'stroke-opacity') asSVGNumberOrPercentage].	(attrs  includesKey: 'stroke-width')		ifTrue: [answer at: 'stroke-width' put: (attrs at: 'stroke-width') asSVGNumber].	(attrs  includesKey: 'display')		ifTrue: [answer at: 'display' put: (attrs at: 'display') withBlanksTrimmed asSymbol].	(attrs  includesKey: 'visibility')		ifTrue: [answer at: 'visibility' put: (attrs at: 'visibility') withBlanksTrimmed asSymbol].	^answer! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2005 20:30'!svgContext	"If our owner chain has an SVGMorph, answer it, otherwise answer the default context."	^(self ownerThatIsA: SVGMorph) ifNil: [self defaultContext]! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/3/2005 10:13'!transformFromSVGAttribute: trans	"Answer a new MatrixTransform2x3 for the transform attribute."	|str matrix|	matrix := MatrixTransform2x3 identity.	trans ifNil: [^matrix].	str := trans readStream.	[str atEnd] whileFalse: [		str upToAny: 'mtsr'. "find the next transform in the list"		matrix := matrix composedWithLocal: (self transformFromSVGAttributeStream: str)].	^matrix! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 09:19'!transformFromSVGAttributeStream: str	"Answer a new MatrixTransform2x3 for the transform (sub)attribute."	|matrix a x y type|	matrix := MatrixTransform2x3 identity.	type := str upTo: $(.	(type = 'matrix')		ifTrue: [matrix				a11: str nextNumber;				a21: str nextNumber;				a12: str nextNumber;				a22: str nextNumber;				a13: str nextNumber;				a23: str nextNumber].	(type = 'translate')		ifTrue: [x := str nextNumber.				y := str nextNumber.				y ifNil: [y := 0].				matrix					setOffset: x@y].	(type = 'scale')		ifTrue: [x := str nextNumber.				y := str nextNumber.				y ifNil: [y := x].								matrix					setScale: x@y].	(type = 'rotate')		ifTrue: [a  := str nextNumber.				x := str nextNumber.				y := str nextNumber.					matrix					setAngle: a.				(x notNil and: [y notNil])					ifTrue: [matrix := ((MatrixTransform2x3 withOffset: x@y)									composedWithLocal: matrix)									composedWithLocal: (MatrixTransform2x3 withOffset: x negated@y negated)]].	(type = 'skewX')		ifTrue: [str match: 'skewX('.				a := str nextNumber.						matrix					setSkew: a@0].	(type = 'skewY')		ifTrue: [str match: 'skewY('.				a := str nextNumber.						matrix					setSkew: 0@a].	^matrix! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/28/2005 11:44'!transformFromSVGElement: anElement	"Answer a new MatrixTransform2x3 for the transform attribute."	^self transformFromSVGAttribute: (anElement attributeAt: 'transform')! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2005 19:09'!userSpaceBoundingBox	"Answer the bounding box of the receiver."	^self userSpaceBoundingBoxWithRespectTo: self! !!SVGComponentMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2005 19:12'!userSpaceBoundingBoxWithRespectTo: aComposite	"Answer the bounding box of the receiver with respect to the transforms	intervening between the receiver and aComposite."	self subclassResponsibility! !!SVGComponentMorph methodsFor: 'accessing' stamp: 'gvc 7/29/2005 21:00'!cachedComposedStyle	"Answer the value of cachedComposedStyle"	^ cachedComposedStyle! !!SVGComponentMorph methodsFor: 'accessing' stamp: 'gvc 7/29/2005 21:00'!cachedComposedStyle: anObject	"Set the value of cachedComposedStyle"	cachedComposedStyle _ anObject! !!SVGComponentMorph methodsFor: 'accessing' stamp: 'gvc 7/28/2005 09:54'!id	"Answer the value of id"	^ id! !!SVGComponentMorph methodsFor: 'accessing' stamp: 'gvc 7/28/2005 09:54'!id: anObject	"Set the value of id"	id _ anObject! !!SVGComponentMorph methodsFor: 'accessing' stamp: 'gvc 10/3/2005 09:04'!printOn: aStream	"Print a description of the receiver on the given stream,"	super printOn: aStream.	aStream 		nextPutAll: '(id=';		nextPutAll: (self id ifNil: ['<none>']);		nextPut: $)! !!SVGComponentMorph methodsFor: 'accessing' stamp: 'gvc 7/28/2005 17:40'!style	"Answer the value of style"	^ style! !!SVGComponentMorph methodsFor: 'accessing' stamp: 'gvc 7/28/2005 17:40'!style: anObject	"Set the value of style"	style _ anObject! !SVGComponentMorph subclass: #SVGCompositeMorph	instanceVariableNames: 'fills'	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 10:45'!antialiasingLevel: anInteger	"Set the level of antialiasing to use when drawing"	super antialiasingLevel: anInteger.	self submorphsDo: [:m |		m antialiasingLevel: anInteger]! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 16:37'!create: anSVGComponentMorphClass fromSVG: anElement	"Create a component from the svg."	|comp|	comp := anSVGComponentMorphClass new.	comp extent: self extent.	comp transform: MatrixTransform2x3 identity.	self addMorph: comp.	^comp createFromSVG: anElement		! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 16:37'!createCircleFromSVGCircle: anElement	"Create a circle from the svg circle."	^self create: SVGCircleMorph fromSVG: anElement! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 16:38'!createEllipseFromSVGEllipse: anElement	"Create an ellipse from the svg ellipse."	^self create: SVGEllipseMorph fromSVG: anElement! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/31/2005 13:07'!createFillFromSVGLinearGradient: anElement	"Create a linear fill style from the given element."		|idg p1 p2 ramp xlink linkFill trans |	idg := (anElement attributeAt: 'id') withBlanksTrimmed.	trans := self transformFromSVGAttribute: (anElement attributeAt: 'gradientTransform').	ramp := self createRampFromSVGGradient: anElement.	xlink := anElement attributeAt: 'xlink:href'.	xlink notNil		ifTrue: [xlink := xlink withBlanksTrimmed.			linkFill := self getFill: xlink allButFirst.			ramp isEmpty				ifTrue: [ramp :=linkFill colorRamp].			p1 := (anElement attributeAt: 'x1' ifAbsent: [linkFill origin x]) asSVGNumberOrPercentage@(anElement attributeAt: 'y1' ifAbsent: [linkFill origin y]) asSVGNumberOrPercentage.			p2 := (anElement attributeAt: 'x2' ifAbsent: [linkFill direction x]) asSVGNumberOrPercentage@(anElement attributeAt: 'y2' ifAbsent: [linkFill direction y]) asSVGNumberOrPercentage]		ifFalse: [			p1 := (anElement attributeAt: 'x1' ifAbsent: [0]) asSVGNumberOrPercentage@(anElement attributeAt: 'y1' ifAbsent: [0]) asSVGNumberOrPercentage.			p2 := (anElement attributeAt: 'x2' ifAbsent: [100]) asSVGNumberOrPercentage@(anElement attributeAt: 'y2' ifAbsent: [100]) asSVGNumberOrPercentage].	p1 := trans transformPoint: p1.	p2 := trans transformPoint: p2 .	self setFill: idg to: ((SVGGradientFillStyle ramp: ramp)		origin: p1;		direction: p2 - p1;		normal: nil;		radial: false;		units: (anElement attributeAt: 'gradientUnits' ifAbsent: [#userSpaceOnUse]) asSymbol;		spread: (anElement attributeAt: 'spreadMethod' ifAbsent: [#pad]) asSymbol)! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/10/2005 14:38'!createFillFromSVGRadialGradient: anElement	"Create a radial fill style from the given element.."		|idg p1 p2 ramp xlink linkFill trans origin direction|	idg := anElement attributeAt: 'id'.	trans := self transformFromSVGAttribute: (anElement attributeAt: 'gradientTransform').	ramp := self createRampFromSVGGradient: anElement.	xlink := anElement attributeAt: 'xlink:href'.	xlink notNil		ifTrue: [			linkFill := self getFill: xlink copyWithoutFirst.			ramp isEmpty				ifTrue: [ramp :=linkFill colorRamp].			p1 := (anElement attributeAt: 'cx' ifAbsent: [linkFill origin x]) asSVGNumberOrPercentage@(anElement attributeAt: 'cy' ifAbsent: [linkFill origin y]) asSVGNumberOrPercentage.			p2 := (anElement attributeAt: 'r' ifAbsent: [linkFill direction x]) asSVGNumberOrPercentage asPoint]		ifFalse: [			p1 := (anElement attributeAt: 'cx' ifAbsent: [50]) asSVGNumberOrPercentage@(anElement attributeAt: 'cy' ifAbsent: [50]) asSVGNumberOrPercentage.			p2 := (anElement attributeAt: 'r' ifAbsent: [50]) asSVGNumberOrPercentage asPoint].	origin := trans transformPoint: p1.	direction := (trans transformPoint: p2 + p1) - origin.	self setFill: idg to: ((SVGGradientFillStyle ramp: ramp)		origin: origin;		direction: direction x@0;		normal: 0@direction y;		radial: true;		units: (anElement attributeAt: 'gradientUnits' ifAbsent: [#userSpaceOnUse]) asSymbol;		spread: (anElement attributeAt: 'spreadMethod' ifAbsent: [#pad]) asSymbol)! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 11:09'!createFromSVG: anElement	"Create the receiver's state from the svg group."	super createFromSVG: anElement.	self processSVGElements: anElement! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 14:41'!createGroupFromSVGGroup: anElement	"Create a group from the svg group."	^self create: SVGGroupMorph fromSVG: anElement! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 16:38'!createLineFromSVGLine: anElement	"Create a line from the svg line."	^self create: SVGLineMorph fromSVG: anElement! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 16:38'!createPathFromSVGPath: anElement	"Create a path from the svg path."	^self create: SVGPathMorph fromSVG: anElement! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 16:39'!createPolygonFromSVGPolygon: anElement	"Create a polygon from the svg polygon."	^self create: SVGPolygonMorph fromSVG: anElement! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 16:39'!createPolylineFromSVGPolyline: anElement	"Create a polyline from the svg polyline."	^self create: SVGPolylineMorph fromSVG: anElement	! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 08:32'!createRampFromSVGGradient: anElement	"Create a color ramp from the given element."		|ramp stopStyle colour ic io stopColor stopOpacity offset|	ramp := OrderedCollection new.	anElement tagsNamed: #stop do: [:stop |		stopColor := stop attributeAt: 'stop-color'.		stopColor ifNotNil: [stopColor := Color fromCSS2String: stopColor].		stopOpacity := stop attributeAt: 'stop-opacity'.		offset := (stop attributeAt: 'offset') asSVGNumberOrPercentage.		stopStyle := (stop attributeAt: 'style' ifAbsent: ['']) subStrings: ':;'.		ic := stopStyle indexOf: 'stop-color'.		ic > 0 ifTrue: [stopColor := Color fromCSS2String: (stopStyle at: ic + 1)].		io := stopStyle indexOf: 'stop-opacity'.		io > 0 ifTrue: [stopOpacity := (stopStyle at: io + 1) asSVGNumberOrPercentage].		stopColor isNil ifTrue: [stopColor := Color black].		stopOpacity isNil ifTrue: [stopOpacity := 1.0].		colour := stopColor alpha: stopOpacity.		ramp add: offset -> colour].	^ramp! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 16:39'!createRectFromSVGRect: anElement	"Create a rect from the svg rect."	^self create: SVGRectMorph fromSVG: anElement! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 16:40'!createTextFromSVGText: anElement	"Create a text from the svg text."	^self create: SVGTextMorph fromSVG: anElement! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:01'!drawSubmorphsOn: aCanvas 	"Display the receiver."		(self composedStyle at: 'display')		ifFalse: [^self].	aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|		balloonCanvas			aaLevel: 3.		super drawSubmorphsOn: balloonCanvas]! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:29'!fills	"Answer the value of fills"	^ fills! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:29'!fills: aDictionary	"Set the value of fills"	fills := aDictionary! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:30'!getFill: name	"Get the fill with the given name."	^self fills at: name ifAbsent: [self context getFill: name]! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:43'!initialize	"Initialize the receiver."	super initialize.	self 		fills: Dictionary new! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/3/2005 09:37'!orderedGradients: tag fromSVG: anElement	"Answer the gradient fills from the given element in an order that will	allow xlinks to be resolved in one pass."	|grads ida idb xlinka xlinkb|	grads := SortedCollection sortBlock: [:a :b |		 ida := (a attributeAt: 'id') withBlanksTrimmed.		idb := (b attributeAt: 'id') withBlanksTrimmed.		xlinka := a attributeAt: 'xlink:href'.		xlinkb := b attributeAt: 'xlink:href'.		xlinka isNil			ifTrue: [true]			ifFalse: [xlinkb isNil					ifTrue: [false]					ifFalse: [xlinkb = ida							ifTrue: [false]							ifFalse: [true]]]		].	anElement tagsNamed: tag do: [:g |		grads add: g].	^grads! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:37'!processSVGElements: anElement	"Process the elements of the given group type element."	anElement elements do: [:e |		e tag == #g			ifTrue: [self createGroupFromSVGGroup: e].		e tag == #rect			ifTrue: [self createRectFromSVGRect: e].		e tag == #circle			ifTrue: [self createCircleFromSVGCircle: e].		e tag == #ellipse			ifTrue: [self createEllipseFromSVGEllipse: e].		e tag == #line			ifTrue: [self createLineFromSVGLine: e].		e tag == #polyline			ifTrue: [self createPolylineFromSVGPolyline: e].		e tag == #polygon			ifTrue: [self createPolygonFromSVGPolygon: e].		e tag == #path			ifTrue: [self createPathFromSVGPath: e].		e tag == #text			ifTrue: [self createTextFromSVGText: e].		e tag == #linearGradient			ifTrue: [self createFillFromSVGLinearGradient: e].		e tag == #radialGradient			ifTrue: [self createFillFromSVGRadialGradient: e]]! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:30'!setFill: name to: aFillStyle	"Set the fill with the given name."		self fills		at: name		put: aFillStyle! !!SVGCompositeMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:02'!userSpaceBoundingBoxWithRespectTo: aComposite	"Answer the bounding box of the receiver with respect to the transforms	intervening between the receiver and aComposite."	|rect|	(self composedStyle at: 'display')		ifFalse: [^self bounds].	self submorphs isEmpty		ifTrue: [^self bounds].	rect := self submorphs first userSpaceBoundingBoxWithRespectTo: aComposite.	self submorphsDo: [:m |		rect := rect merge: (m userSpaceBoundingBoxWithRespectTo: aComposite)].	^rect! !LineSegment subclass: #SVGFixupLineSegment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGFixupLineSegment methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 14:12'!primAddToEngine: aBalloonEngine fills: fills lineWidth: lineWidth	"Add the receiver's description to the ballooon engine."	aBalloonEngine		primAddPolygon: {start. end}		segments: 2		fill: (fills at: 1)		lineWidth: 1		lineFill: 0! !!SVGFixupLineSegment methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 12:51'!runClass	"Answer the run class for the receiver."	^SVGFixupLineSegmentRun! !GradientFillStyle subclass: #SVGGradientFillStyle	instanceVariableNames: 'units spread'	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGGradientFillStyle methodsFor: 'accessing' stamp: 'gvc 8/2/2005 13:21'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastColor lastIndex nextIndex nextColor distance theta ramp step lastWord nextWord |	ramp := colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits := Bitmap new: length.	lastColor := ramp first value.	lastWord := lastColor pixelWord32.	lastIndex := 0.	ramp do:[:assoc|		nextIndex := (assoc key * length) rounded.		nextColor := assoc value.		nextWord := nextColor pixelWord32.		distance := nextIndex - lastIndex.		distance = 0 ifTrue: [distance := 1].		step := 1.0 / distance.		theta := 0.0.		lastIndex+1 to: nextIndex do: [:i|			theta := theta + step.			bits at: i put: (self interpolatedAlphaMix: theta of: lastWord and: nextWord)].		lastIndex := nextIndex.		lastColor := nextColor.		lastWord := nextWord].	lastIndex+1 to: length do: [:i| bits at: i put: lastWord].	^bits! !!SVGGradientFillStyle methodsFor: 'accessing' stamp: 'gvc 8/2/2005 13:21'!interpolatedAlphaMix: ratio of: rgba1 and: rgba2	"Answer a proper interpolated value between to RGBA color words.	Theta is 0..1.."	| a1 a2 ra ira rgb1 rgb2 alpha br1 br2 bg1 bg2 bb1 bb2 result |	a1 := rgba1 bitShift: -24. a2 := rgba2 bitShift: -24.	alpha := ratio * (a2 - a1) + a1.	ra := ratio * alpha.	ira := (1.0 - ratio) * alpha.	rgb1 := rgba1 bitAnd: 16rFFFFFF. rgb2 := rgba2 bitAnd: 16rFFFFFF.	br1 := (rgb1 bitAnd: 255). br2 := (rgb2 bitAnd: 255).	bg1 := ((rgb1 bitShift:  -8) bitAnd: 255). bg2 := ((rgb2 bitShift: -8) bitAnd: 255).	bb1 := ((rgb1 bitShift: -16) bitAnd: 255). bb2 := ((rgb2 bitShift: -16) bitAnd: 255).	result :=  (ra * br2 + (ira * br1)) rounded // 255.	result :=  result bitOr: ((ra * bg2 + (ira * bg1)) rounded // 255 bitShift: 8).	result :=  result bitOr: ((ra * bb2 + (ira * bb1)) rounded // 255 bitShift: 16).	^result bitOr: (alpha rounded bitShift: 24)! !!SVGGradientFillStyle methodsFor: 'accessing' stamp: 'gvc 10/31/2005 13:22'!mappedTo: anSVGComponentMorph	"Answer a copy of the receiver with the appropriate origin and direction."	self mapsToObjectBounds		ifTrue: [^self mappedToBounds: anSVGComponentMorph globalBoundingBox].	^self! !!SVGGradientFillStyle methodsFor: 'accessing' stamp: 'gvc 10/31/2005 13:11'!mappedToBounds: aRectangle	"Answer a copy of the receiver with the appropriate origin and direction."	|o|	self mapsToObjectBounds		ifTrue: [^self copy				origin: (o := aRectangle origin + ( self origin * aRectangle extent));				direction: self direction + self origin * aRectangle extent - o;				normal: nil].	^self! !!SVGGradientFillStyle methodsFor: 'accessing' stamp: 'gvc 7/30/2005 20:25'!mapsToObjectBounds	"Answer whether the units specify a mapping to an object bounding box"	^self units == #objectBoundingBox! !!SVGGradientFillStyle methodsFor: 'accessing' stamp: 'gvc 7/30/2005 20:00'!spread	"Answer the value of spread"	^ spread! !!SVGGradientFillStyle methodsFor: 'accessing' stamp: 'gvc 7/30/2005 20:00'!spread: anObject	"Set the value of spread"	spread _ anObject! !!SVGGradientFillStyle methodsFor: 'accessing' stamp: 'gvc 7/30/2005 20:00'!units	"Answer the value of units"	^ units! !!SVGGradientFillStyle methodsFor: 'accessing' stamp: 'gvc 7/30/2005 20:00'!units: anObject	"Set the value of units"	units _ anObject! !SVGCompositeMorph subclass: #SVGGroupMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!SVGCompositeMorph subclass: #SVGMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGMorph methodsFor: 'accessing' stamp: 'gvc 7/29/2005 21:22'!composedStyle	"Answer the composed style dicrionary"	self cachedComposedStyle isNil		ifTrue: [self cachedComposedStyle: self style].	^self cachedComposedStyle! !!SVGMorph methodsFor: 'accessing' stamp: 'gvc 8/1/2005 13:32'!createDefsFromSVGDefs: anElement	"Create the receiver's definitions from the given defs element."	self createFillsFromSVG: anElement! !!SVGMorph methodsFor: 'accessing' stamp: 'gvc 7/30/2005 10:21'!createFromSVG: anElement	"Create the receiver from the given svg element"	self removeAllMorphs.	self setDimensionsFromSVG: anElement.	anElement tagsNamed: #defs do: [:defs |		self createDefsFromSVGDefs: defs].	super createFromSVG: anElement! !!SVGMorph methodsFor: 'accessing' stamp: 'gvc 7/30/2005 10:17'!createFromSVGDocument: aDocument	"Create the receiver from the given xml document"	|svg|	svg := (aDocument firstTagNamed: #svg) ifNil: [self error: 'Missing svg element'].	self createFromSVG: svg! !!SVGMorph methodsFor: 'accessing' stamp: 'gvc 7/28/2005 09:13'!defaultColor	"answer the default color/fill style for the receiver."	^ Color white! !!SVGMorph methodsFor: 'accessing' stamp: 'gvc 7/29/2005 09:22'!defaultViewBox	"Set the receiver's dimensions from the given svg element."	^0@0 extent: 300@500! !!SVGMorph methodsFor: 'accessing' stamp: 'dominik 12/22/2011 14:20:21.454'!drawOn: aCanvas 	"Display the receiver."		super drawOn: aCanvas.	aCanvas frameAndFillRectangle: self bounds fillColor: self color borderWidth: 0 borderColor: Color black! !!SVGMorph methodsFor: 'accessing' stamp: 'gvc 7/30/2005 22:19'!drawSubmorphsOn: aCanvas 	"Display the receiver."		|balloonCanvas|	balloonCanvas := aCanvas asBalloonCanvas.	super drawSubmorphsOn: balloonCanvas! !!SVGMorph methodsFor: 'accessing' stamp: 'gvc 7/30/2005 20:12'!getFill: name	"Get the fill with the given name."		^self fills at: name! !!SVGMorph methodsFor: 'accessing' stamp: 'gvc 8/1/2005 13:42'!initialize	"Initialize the receiver."	super initialize.	self 		clipSubmorphs: true! !!SVGMorph methodsFor: 'accessing' stamp: 'gvc 10/3/2005 17:13'!setDimensionsFromSVG: anElement	"Set the receiver's dimensions from the given svg element."	|w h viewBox str|	w := anElement attributeAt: 'width'ifAbsent: ['100%'].	h := anElement attributeAt: 'height' ifAbsent: ['100%'].	str := anElement attributeAt: 'viewBox'.	viewBox := str isNil		ifTrue: [self defaultViewBox]		ifFalse: [str := str readStream.				str nextNumber@str nextNumber extent: str nextNumber@str nextNumber].	(w withBlanksTrimmed endsWith: '%')		ifTrue: [w := viewBox width * w asNumber // 100]		ifFalse: [(w withBlanksTrimmed endsWith: 'mm')				ifTrue: [w := (w asNumber * 3.571429) rounded]				ifFalse: [w := w asInteger]].	(h withBlanksTrimmed endsWith: '%')		ifTrue: [h := viewBox height * h asNumber // 100]		ifFalse: [(h withBlanksTrimmed endsWith: 'mm')				ifTrue: [h := (h asNumber * 3.571429) rounded]				ifFalse: [h := h asInteger]].	self extent: w@h! !!SVGMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/3/2005 08:44'!createFillsFromSVG: anElement	"Create the receiver's fills from the given element."	(self orderedGradients: #linearGradient fromSVG: anElement) do: [:g |		self createFillFromSVGLinearGradient: g].	(self orderedGradients: #radialGradient fromSVG: anElement) do: [:g |		self createFillFromSVGRadialGradient: g]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SVGMorph class	instanceVariableNames: ''!!SVGMorph class methodsFor: 'as yet unclassified' stamp: 'gvc 10/17/2005 17:41'!example	"SVGMorph example"	|s svg w|	s := FileList2 modalFileSelectorForSuffixes: #('svg' 'svgz').	s ifNil: [^nil].	[svg := self fromFileStream: s]		ensure: [s close].	w := SystemWindow labelled: s name.	w extent: svg extent.	w		addMorph: svg		frame: (0@0 corner: 1@1);		clipSubmorphs: true;		openAsIs! !!SVGMorph class methodsFor: 'as yet unclassified' stamp: 'gvc 10/17/2005 17:40'!fromFile: filename	"Open an SVGMorph from the given file."	| s answer|	s := FileStream oldFileNamed: filename.	s ifNil: [^nil].	[answer _ self fromFileStream: s]		ensure: [s close].	^answer! !!SVGMorph class methodsFor: 'as yet unclassified' stamp: 'gvc 10/17/2005 17:39'!fromFileStream: aStream	"Open an SVGMorph from the given stream."	|sx doc|	sx := aStream.	(aStream name endsWith: 'svgz')		ifTrue: [aStream binary.				sx := (GZipReadStream on: aStream contentsOfEntireFile) upToEnd asString readStream].	doc :=(XMLDOMParser parseDocumentFrom: sx).	^self new createFromSVGDocument: doc! !SVGComponentMorph subclass: #SVGPathMorph	instanceVariableNames: 'segments'	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/28/2005 15:40'!addSegment: aLineSegment	"Add a line segment to the list of segments."	self segments add: aLineSegment! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/12/2005 12:18'!adjustSegmentEnds	"Adjust the end segments if not closed."	|p1 p2 sw angle first last|	self halt.	self segments isEmpty		ifTrue: [^self].	first := self segments first.	last := self segments last.	first class == LineSegment		ifTrue: [p1 := first start.				p2 := first end.				(self composedStyle at: 'stroke-linecap') = #butt					ifTrue: [sw := (self composedStyle at: 'stroke-width') / 2.						angle := (p1 bearingToPoint: p2) - 90.						p1 := p1 + (Point r: sw degrees: angle).						first from: p1 to: p2]].	last class == LineSegment		ifTrue: [p1 := last start.				p2 := last end.				(self composedStyle at: 'stroke-linecap') = #butt					ifTrue: [sw := (self composedStyle at: 'stroke-width') / 2.						angle := (p1 bearingToPoint: p2) - 90.						p2 := p2 - (Point r: sw degrees: angle).						last from: p1 to: p2]]! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/3/2005 15:44'!createArcSegmentFrom: data at: aPoint	"Create an arc segment from the path data at the given position.	Evil apporximation required for compatability with Balloon - no arcs!!"	|position radii angle sweep large sp cp pd num root s cd c theta1 dtheta nSegs delta t ps|	radii := (data first@data second) abs.	angle := data third degreesToRadians.	large := data fourth = 1.	sweep := data fifth = 1.	position  := data sixth@data seventh.	ps := aPoint.	position = aPoint		ifTrue: [^position].	(radii x = 0 or: [radii y = 0])		ifTrue: [^self createLineSegmentFrom: aPoint to: position].	sp := angle sin.	cp := angle cos.	pd := (cp * (ps x - position x) + (sp * (ps y - position y)) @		(sp negated * (ps x - position x) + (cp * (ps y - position y)))) / 2.	num := radii x squared * radii y squared - (radii x squared * pd y squared) - (radii y squared * pd x squared).	num < 0		ifTrue: [s :=  (1 - (num / (radii x squared * radii y squared))) sqrt.				radii := radii * s.				root := 0]		ifFalse: [root := (large = sweep ifTrue: [-1] ifFalse: [1]) *					(num / (radii x squared * pd y squared + (radii y squared * pd x squared))) sqrt].	cd := root * radii * pd transposed / radii transposed.	cd := cd x @ cd y negated.	c := cp * cd x - (sp * cd y) + (ps x + position x / 2) @		(sp * cd x + (cp * cd y) + (ps y + position y / 2)).	theta1 := 1@0 angleWith: pd - cd / radii.	dtheta := pd - cd / radii angleWith: pd negated - cd / radii.	(sweep not and: [dtheta > 0])		ifTrue: [dtheta := dtheta  - (2 * Float pi)]		ifFalse: [(sweep and: [dtheta < 0])				ifTrue: [dtheta := dtheta + (2 * Float pi)]].	nSegs := (dtheta / (Float pi /2)) abs ceiling.	delta := dtheta / nSegs.	t := 8 / 3 * (delta / 4) sin squared / (delta / 2) sin.	nSegs timesRepeat: [|ct1 st1 theta2 ct2 st2 pe ds de|		ct1 := theta1 cos.		st1 := theta1 sin.		theta2 := theta1 + delta.		ct2 := theta2 cos.		st2 := theta2 sin.		pe := cp * radii x * ct2 - (sp * radii y * st2) + c x @			(sp * radii x * ct2 + (cp * radii y  * st2) + c y).		 ds := t * ((cp negated * radii x * st1 - (sp * radii y * ct1)) @			(sp negated  * radii x * st1 + (cp * radii y*ct1))).		de := t * ((cp * radii x * st2 + (sp * radii y * ct2)) @			(sp  * radii x * st2 - (cp * radii y*ct2))).		self			createCubicBezierSegmentFrom: ps			via: ps + ds			and: pe + de			to: pe.		theta1 := theta2.		ps := pe].	^position! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/8/2005 13:52'!createClosingLineSegmentFrom: start to: end	"Create a line segment from the start to the end."	self addSegment: (SVGClosingLineSegment from: start to: end).	^end! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/29/2005 00:04'!createCubicBezierSegmentFrom: data at: aPoint	"Create a cubic bezier segment from the path data (stream) at the given position."	|position|	self		createCubicBezierSegmentFrom: aPoint		via: data first@data second		and: data third@data fourth		to: (position _ data fifth@data sixth).	^position! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/28/2005 16:00'!createCubicBezierSegmentFrom: start via: control1 and: control2 to: end	"Create a cubic bezier segment from the start to the end via the control points."	(control1 = start or: [control2 = end])		ifTrue: [control1 = start				ifTrue: [control2 = end						ifTrue: [self createLineSegmentFrom: start to: end]						ifFalse: [self createQuadraticBezierSegmentFrom: start via: control2 to: end]]				ifFalse: [self createQuadraticBezierSegmentFrom: start via: control1 to: end]]		ifFalse: [self addSegment: (Bezier3Segment from: start via: control1 and: control2 to: end)]! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 14:13'!createFixupLineSegmentFrom: start to: end	"Create a line segment from the start to the end."	self addSegment: (SVGFixupLineSegment from: start to: end).	^end! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 12:57'!createFromSVG: anElement	"Create a path from the svg path."	super createFromSVG: anElement.	self createSegmentsFromSVG: anElement! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/29/2005 00:34'!createLineSegmentFrom: data at: aPoint	"Create a line segment from the path data (stream) at the given position."	|position|	self createLineSegmentFrom: aPoint to: (position _ data first@data second).	^position! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/12/2005 12:08'!createLineSegmentFrom: start to: end	"Create a line segment from the start to the end."	self addSegment: (LineSegment from: start to: end).	^end! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/29/2005 00:04'!createQuadraticBezierSegmentFrom: data at: aPoint	"Create a quadratic bezier segment from the path data (stream) at the given position."		|position|	self		createQuadraticBezierSegmentFrom: aPoint		via: data first@data second		to: (position _ data third@data fourth).	^position! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/28/2005 15:59'!createQuadraticBezierSegmentFrom: start via: control to: end	"Create a cubic bezier segment from the start to the end via the control points."	(control = start or: [control = end])		ifTrue: [self createLineSegmentFrom: start to: end]		ifFalse: [self addSegment: (Bezier2Segment from: start via: control to: end)]! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 14:13'!createSegmentsFromSVG: anElement	"Create the segments from the path."	|data position c d subpathStartPosition initialPosition lastCubicControl lastQuadraticControl|	c := nil.	initialPosition := nil.	data := self pathDataFromSVG: anElement.	position := 0@0.	data do: [:cmd |		((cmd = $S or: [cmd = $s]) and: ['CcSs' includes: c not])			ifTrue: [lastCubicControl := position].		((cmd = $T or: [cmd = $t]) and: ['QqTt' includes: c not])			ifTrue: [lastQuadraticControl := position].		c := cmd key.		d := cmd value.		c = $M			ifTrue: [position := d first@d second.					initialPosition isNil						ifTrue: [initialPosition := position].								subpathStartPosition := position].		c = $m			ifTrue: [initialPosition isNil						ifTrue: [position := d first@d second. initialPosition :=  position]						ifFalse: [position := position + (d first@d second)].					subpathStartPosition := position].		c = $A			ifTrue: [position := self createArcSegmentFrom: d at: position].		c = $a			ifTrue: [d at: 1 put: (d first + position x).					d at: 2 put: (d second + position y).					d at: 6 put: (d sixth + position x).					d at: 7 put: (d seventh + position y).					position := self createArcSegmentFrom: d at: position].		c = $L			ifTrue: [position := self createLineSegmentFrom: d at: position].		c = $l			ifTrue: [d at: 1 put: (d first + position x).					d at: 2 put: (d second + position y).					position := self createLineSegmentFrom: d at: position].		c = $H			ifTrue: [d add: position y.					position := self createLineSegmentFrom: d at: position].		c = $h			ifTrue: [d at: 1 put: (d first + position x).					d add: position y.					position := self createLineSegmentFrom: d at: position].		c = $V			ifTrue: [d addFirst: position x.					position := self createLineSegmentFrom: d at: position].		c = $v			ifTrue: [d addFirst: position x.					d at: 2 put: (d second + position y).					position := self createLineSegmentFrom: d at: position].		c = $C			ifTrue: [lastCubicControl := d third@d fourth.					position := self createCubicBezierSegmentFrom: d at: position].		c = $c			ifTrue: [d at: 1 put: (d first + position x).					d at: 2 put: (d second + position y).					d at: 3 put: (d third + position x).					d at: 4 put: (d fourth + position y).					lastCubicControl := d third@d fourth.					d at: 5 put: (d fifth + position x).					d at: 6 put: (d sixth + position y).					position := self createCubicBezierSegmentFrom: d at: position].		c = $S			ifTrue: [lastCubicControl := lastCubicControl reflectedAbout: position.					d addFirst: lastCubicControl y.					d addFirst: lastCubicControl x.					lastCubicControl := d third@d fourth.					position := self createCubicBezierSegmentFrom: d at: position].		c = $s			ifTrue: [lastCubicControl := lastCubicControl reflectedAbout: position.					d addFirst: lastCubicControl y.					d addFirst: lastCubicControl x.					d at: 3 put: (d third + position x).					d at: 4 put: (d fourth + position y).					lastCubicControl := d third@d fourth.					d at: 5 put: (d fifth + position x).					d at: 6 put: (d sixth + position y).					position := self createCubicBezierSegmentFrom: d at: position].		c = $Q			ifTrue: [lastQuadraticControl := d first@d second .					position := self createQuadraticBezierSegmentFrom: d at: position].		c = $q			ifTrue: [d at: 1 put: (d first + position x).					d at: 2 put: (d second + position y).					lastQuadraticControl := d first@d second.					d at: 3 put: (d third + position x).					d at: 4 put: (d fourth + position y).					position := self createQuadraticBezierSegmentFrom: d at: position].		c = $T			ifTrue: [lastQuadraticControl := lastQuadraticControl reflectedAbout: position.					d addFirst: lastQuadraticControl y.					d addFirst: lastQuadraticControl x.					lastQuadraticControl := d first@d second.					position := self createQuadraticBezierSegmentFrom: d at: position].		c = $t			ifTrue: [lastQuadraticControl := lastQuadraticControl reflectedAbout: position.					d addFirst: lastCubicControl y.					d addFirst: lastCubicControl x.					lastQuadraticControl := d first@d second.					d at: 3 put: (d third + position x).					d at: 4 put: (d fourth + position y).					position := self createQuadraticBezierSegmentFrom: d at: position].		(c = $z and: [position ~= subpathStartPosition])			ifTrue: [position := self createClosingLineSegmentFrom: position to: subpathStartPosition]].	(c ~=$z and: [position ~= subpathStartPosition])		ifTrue: [position := self createFixupLineSegmentFrom: position to: subpathStartPosition]! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:06'!drawOn: aCanvas	"Draw the component on the canvas."		(self composedStyle at: 'visibility')		ifFalse: [^self].	super drawOn: aCanvas.	self renderer		renderPath: self		on: aCanvas! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/28/2005 15:24'!initialize	"Initialize the receiver."	super initialize.	self 		segments: OrderedCollection new! !!SVGPathMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/3/2005 10:15'!pathDataFromSVG: anElement	"Answer a collection of parameters from the path data."	|data path c cmds params str n sizes size|	cmds := 'zMmLlCcQqAaHhVvSsTt'.	sizes := #(0 2 2 2 2 6 6 4 4 7 7 1 1 1 1 4 4 2 2).	path := (anElement attributeAt: 'd') readStream.	data := OrderedCollection new.	[path atEnd] whileFalse: [		(path upToAny: cmds).		c := path next.		str := (path upToAny: cmds) readStream.		params := OrderedCollection new.		[str atEnd or: [(n := str nextNumber) isNil]] whileFalse: [			params add: n].		c = $z			ifTrue: [data add: c-> #()].		(c = $M and: [params size > 2])			ifTrue: [data add: c -> (params first: 2).					c := $L.					params := params allButFirst: 2].		(c = $m and: [params size > 2])			ifTrue: [data add: c -> (params first: 2).					c := $l.					params := params allButFirst: 2].		size := sizes at: (cmds indexOf: c).		size > 0			ifTrue: [1 to: params size by: (size := sizes at: (cmds indexOf: c)) do: [:i |					data add: c -> (params copyFrom: i to: i + size - 1)]]].	^data! !!SVGPathMorph methodsFor: 'accessing' stamp: 'gvc 7/28/2005 15:24'!segments	"Answer the value of segments"	^ segments! !!SVGPathMorph methodsFor: 'accessing' stamp: 'gvc 7/28/2005 15:24'!segments: anObject	"Set the value of segments"	segments _ anObject! !!SVGPathMorph methodsFor: 'accessing' stamp: 'gvc 7/30/2005 20:47'!userSpaceBoundingBoxWithRespectTo: aComposite	"Answer the bounding box of the receiver with respect to the transforms	intervening between the receiver and aComposite."	|rect subRect trans|	self segments isEmpty		ifTrue: [^nil].	trans := self transformFrom: aComposite.					rect := self segments first boundingBox boundsWithTransform: trans.	self segments do: [:s |		subRect := s boundingBox.		subRect notNil			ifTrue: [subRect := subRect boundsWithTransform: trans.					rect := rect merge: subRect]].	^rect! !SVGComponentMorph subclass: #SVGPolygonalMorph	instanceVariableNames: 'points'	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGPolygonalMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:54'!createFromSVG: anElement	"Create a polygon from the svg polygon."	super createFromSVG: anElement.	self createPointsFromSVG: anElement! !!SVGPolygonalMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:54'!createPointsFromSVG: anElement	"Create the points from the polygon."	self points: (self pointDataFromSVG: anElement)! !!SVGPolygonalMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:54'!initialize	"Initialize the receiver."	super initialize.	self 		points: OrderedCollection new! !!SVGPolygonalMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2005 12:16'!pointDataFromSVG: anElement	"Answer a collection of points from the polygon data."		|pts str x y|	pts := OrderedCollection new.	str := (anElement attributeAt: 'points') readStream.	[str atEnd] whileFalse: [		x _ str nextNumber.		y _ str nextNumber.		(x notNil and: [y notNil])			ifTrue: [pts add: x@y]].	^pts! !!SVGPolygonalMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:54'!points	"Answer the value of points"	^ points! !!SVGPolygonalMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:54'!points: anObject	"Set the value of points"	points := anObject! !SVGPolygonalMorph subclass: #SVGPolygonMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGPolygonMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:06'!drawOn: aCanvas	"Draw the component on the canvas."		(self composedStyle at: 'visibility')		ifFalse: [^self].	super drawOn: aCanvas.	self renderer		renderPolygon: self		on: aCanvas! !SVGPolygonalMorph subclass: #SVGPolylineMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGPolylineMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:06'!drawOn: aCanvas	"Draw the component on the canvas."		(self composedStyle at: 'visibility')		ifFalse: [^self].	super drawOn: aCanvas.	self renderer		renderPolyline: self		on: aCanvas! !Dictionary subclass: #SVGPropertyDictionary	instanceVariableNames: 'parents'	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGPropertyDictionary methodsFor: 'accessing' stamp: 'gvc 8/8/2005 11:54'!addParent: anObject	"Add an object to the receiver's parents.."	self parents add: anObject! !!SVGPropertyDictionary methodsFor: 'accessing' stamp: 'gvc 8/8/2005 11:54'!initialize	"Initialize the receiver."	super initialize.	self		parents: OrderedCollection new! !!SVGPropertyDictionary methodsFor: 'accessing' stamp: 'gvc 8/8/2005 11:53'!parents	"Answer the value of parents"	^ parents! !!SVGPropertyDictionary methodsFor: 'accessing' stamp: 'gvc 8/8/2005 11:53'!parents: anObject	"Set the value of parents"	parents _ anObject! !!SVGPropertyDictionary methodsFor: 'as yet unclassified' stamp: 'gvc 8/8/2005 11:31'!propertyAt: key	"Answer the inherited property value for the given key"	^self findFirstBreadthwise: [:o | o parents] suchThat: [:p | p includesKey: key]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SVGPropertyDictionary class	instanceVariableNames: ''!!SVGPropertyDictionary class methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:20'!withDefaults	"Answer a new instance of the receiver with the default values."	^self new		at: 'opacity' put: 1.0;		at: 'fill' put: Color black;		at: 'fill-opacity' put: 1.0;		at: 'fill-rule' put: #nonzero;		at: 'stroke' put: Color transparent;		at: 'stroke-opacity' put: 1.0;		at: 'stroke-width' put: 1.0;		at: 'stroke-linecap' put: #square;		at: 'font-family' put: nil;		at: 'font-size' put: 12;		at: 'text-anchor' put: #start;		at: 'display' put: #inline;		at: 'visibility' put: #visible;		yourself! !!SVGPropertyDictionary class methodsFor: 'as yet unclassified' stamp: 'gvc 8/8/2005 12:25'!withParent: anObject	"Answer a new instance of the receiver with the given parent."	anObject ifNil: [^self withDefaults].	^self new		parents: (OrderedCollection with: anObject)! !!SVGPropertyDictionary class methodsFor: 'as yet unclassified' stamp: 'gvc 8/8/2005 12:25'!withParents: aCollection	"Answer a new instance of the receiver with the given parents."	aCollection isEmpty ifTrue: [^self withDefaults].	^self new		parents: aCollection asOrderedCollection copy! !SVGComponentMorph subclass: #SVGRectangularMorph	instanceVariableNames: 'rectangle'	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGRectangularMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:49'!createFromSVG: anElement	"Create a rectangle from the svg rect."	super createFromSVG: anElement.	self createRectangleFromSVG: anElement! !!SVGRectangularMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:50'!createRectangleFromSVG: anElement	"Create the segments from the rect."	self subclassResponsibility! !!SVGRectangularMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:49'!rectangle	"Answer the value of rectangle"	^ rectangle! !!SVGRectangularMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:49'!rectangle: anObject	"Set the value of rectangle"	rectangle := anObject! !!SVGRectangularMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 13:50'!userSpaceBoundingBoxWithRespectTo: aComposite	"Answer the bounding box of the receiver with respect to the transforms	intervening between the receiver and aComposite."	^self rectangle boundsWithTransform: (self transformFrom: aComposite)! !SVGRectangularMorph subclass: #SVGEllipseMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGEllipseMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:08'!createRectangleFromSVG: anElement	"Create the bounding rectangle from the svg ellipse."	self 		rectangle: (Rectangle			center: (anElement attributeAt: 'cx' ifAbsent: [0]) asSVGNumber@(anElement attributeAt: 'cy' ifAbsent: [0]) asSVGNumber			extent: (anElement attributeAt: 'rx' ifAbsent: [0]) asSVGNumber@((anElement attributeAt: 'ry' ifAbsent: [0]) asSVGNumber) * 2)! !!SVGEllipseMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:06'!drawOn: aCanvas	"Draw the component on the canvas."		(self composedStyle at: 'visibility')		ifFalse: [^self].	super drawOn: aCanvas.	self renderer		renderEllipse: self		on: aCanvas! !SVGEllipseMorph subclass: #SVGCircleMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGCircleMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 08:34'!createRectangleFromSVG: anElement	"Create the bounding rectangle from the svg circle."	self		rectangle: (Rectangle			center: (anElement attributeAt: 'cx' ifAbsent: [0]) asSVGNumber@(anElement attributeAt: 'cy' ifAbsent: [0]) asSVGNumber			extent: (anElement attributeAt: 'r' ifAbsent: [0]) asSVGNumber  asPoint * 2)! !SVGRectangularMorph subclass: #SVGLineMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGLineMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:08'!createRectangleFromSVG: anElement	"Create the segments from the rect."	self		rectangle:  ((anElement attributeAt: 'x1' ifAbsent: [0]) asSVGNumber@(anElement attributeAt: 'y1' ifAbsent: [0]) asSVGNumber					corner: (anElement attributeAt: 'x2' ifAbsent: [0]) asSVGNumber@(anElement attributeAt: 'y2' ifAbsent: [0]) asSVGNumber)! !!SVGLineMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:06'!drawOn: aCanvas	"Draw the component on the canvas."		(self composedStyle at: 'visibility')		ifFalse: [^self].	super drawOn: aCanvas.	self renderer		renderLine: self		on: aCanvas! !SVGRectangularMorph subclass: #SVGRectMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGRectMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:09'!createRectangleFromSVG: anElement	"Create the segments from the rect."	self		rectangle:  ((anElement attributeAt: 'x' ifAbsent: [0]) asSVGNumber@(anElement attributeAt: 'y' ifAbsent: [0]) asSVGNumber					extent: (anElement attributeAt: 'width') asSVGNumber@(anElement attributeAt: 'height') asSVGNumber)! !!SVGRectMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:06'!drawOn: aCanvas	"Draw the component on the canvas."	(self composedStyle at: 'visibility')		ifFalse: [^self].	super drawOn: aCanvas.	self renderer		renderRect: self		on: aCanvas! !Object subclass: #SVGRenderer	instanceVariableNames: ''	classVariableNames: 'DefaultRenderer'	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:09'!renderCircle: anSVGLine on: aCanvas	"Render the given object on the canvas."	self subclassResponsibility! !!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:15'!renderEllipse: anSVGEllipse on: aCanvas	"Render the given object on the canvas."	self subclassResponsibility! !!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:06'!renderLine: anSVGLine on: aCanvas	"Render the given object on the canvas."	self subclassResponsibility! !!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:05'!renderPath: anSVGPath on: aCanvas	"Render the given object on the canvas."	self subclassResponsibility! !!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:16'!renderPolygon: anSVGPolygon on: aCanvas	"Render the given object on the canvas."	self subclassResponsibility! !!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:14'!renderPolyline: anSVGPolyine on: aCanvas	"Render the given object on the canvas."	self subclassResponsibility! !!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:13'!renderRect: anSVGRect on: aCanvas	"Render the given object on the canvas."		self subclassResponsibility! !!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:09'!renderTSpan: anSVGLine on: aCanvas	"Render the given object on the canvas."	self subclassResponsibility! !!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:13'!renderText: anSVGText on: aCanvas	"Render the given object on the canvas."		self subclassResponsibility! !!SVGRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/14/2005 11:00'!styleIn: aComponent fromSVGStyle: svgStyle	"Answer a dictionary of the style parameters for the given svg style dictionary."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SVGRenderer class	instanceVariableNames: ''!!SVGRenderer class methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:03'!default	"Answer the default renderer."	^DefaultRenderer ifNil: [^DefaultRenderer := SVGBalloonRenderer new]! !SVGRenderer subclass: #SVGBalloonRenderer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGBalloonRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:15'!renderEllipse: anSVGEllipse on: aCanvas	"Render the given object on the canvas."		|fill lineWidth lineColor|	fill := anSVGEllipse composedFillStyle.	lineWidth := (anSVGEllipse composedStyle at: 'stroke-width') rounded max: 1.	lineColor := anSVGEllipse composedStyle at: 'stroke'.	aCanvas asBalloonCanvas preserveStateDuring: [:bc|		bc transformBy: anSVGEllipse transform during: [:balloonCanvas |			balloonCanvas				aaLevel: anSVGEllipse antialiasingLevel;				drawOval: anSVGEllipse rectangle				color: fill				borderWidth: lineWidth				borderColor: lineColor]]! !!SVGBalloonRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:07'!renderLine: anSVGLine on: aCanvas	"Render the given object on the canvas."		| lineWidth lineColor|	lineWidth := (anSVGLine composedStyle at: 'stroke-width') rounded max: 1.	lineColor := anSVGLine composedStyle at: 'stroke'.	aCanvas asBalloonCanvas preserveStateDuring: [:bc|		bc transformBy: anSVGLine transform during: [:balloonCanvas |			balloonCanvas				aaLevel: anSVGLine antialiasingLevel;				drawPolygon: {anSVGLine rectangle origin. anSVGLine rectangle corner}				color: lineColor				borderWidth: lineWidth				borderColor: lineColor]]! !!SVGBalloonRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:04'!renderPath: anSVGPath on: aCanvas	"Render the given object on the canvas."	|fill lineWidth lineColor|	anSVGPath segments isEmpty		ifTrue: [^self].	fill := anSVGPath composedFillStyle.	lineWidth := (anSVGPath composedStyle at: 'stroke-width') rounded max: 1.	lineColor := anSVGPath composedStyle at: 'stroke'.	aCanvas asBalloonCanvas preserveStateDuring: [:bc|		bc transformBy: anSVGPath transform during: [:balloonCanvas |			balloonCanvas				aaLevel: anSVGPath antialiasingLevel;				drawGeneralSegments: anSVGPath segments				color: fill				borderWidth: lineWidth				borderColor: lineColor]]! !!SVGBalloonRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:17'!renderPolygon: anSVGPolygon on: aCanvas	"Render the given object on the canvas."		|fill lineWidth lineColor|	anSVGPolygon points isEmpty		ifTrue: [^anSVGPolygon].	fill := anSVGPolygon composedFillStyle.	lineWidth := anSVGPolygon composedStyle at: 'stroke-width'.	lineColor := anSVGPolygon composedStyle at: 'stroke'.	aCanvas asBalloonCanvas preserveStateDuring: [:bc|		bc transformBy: anSVGPolygon transform during: [:balloonCanvas |			balloonCanvas				aaLevel: anSVGPolygon antialiasingLevel;				drawPolygon: anSVGPolygon points asArray				color: fill				borderWidth: (lineWidth rounded max: 1)				borderColor: lineColor]]! !!SVGBalloonRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:14'!renderPolyline: anSVGPolyine on: aCanvas	"Render the given object on the canvas."		| lineWidth lineColor|	anSVGPolyine points isEmpty		ifTrue: [^anSVGPolyine].	lineWidth := anSVGPolyine composedStyle at: 'stroke-width'.	lineColor := anSVGPolyine composedStyle at: 'stroke'.	aCanvas asBalloonCanvas preserveStateDuring: [:bc|		bc transformBy: anSVGPolyine transform during: [:balloonCanvas |			balloonCanvas				aaLevel: anSVGPolyine antialiasingLevel;				drawOpenPolygon: anSVGPolyine points asArray				color: Color transparent				borderWidth: (lineWidth rounded max: 1)				borderColor: lineColor]]! !!SVGBalloonRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 8/4/2005 10:13'!renderRect: anSVGRect on: aCanvas	"Render the given object on the canvas."	|fill lineWidth lineColor|	fill := anSVGRect composedFillStyle.	lineWidth := (anSVGRect composedStyle at: 'stroke-width') rounded max: 1.	lineColor := anSVGRect composedStyle at: 'stroke'.	aCanvas asBalloonCanvas preserveStateDuring: [:bc|		bc transformBy: anSVGRect transform during: [:balloonCanvas |			balloonCanvas				aaLevel: anSVGRect antialiasingLevel;				drawRectangle: anSVGRect rectangle				color: fill				borderWidth: lineWidth				borderColor: lineColor]]! !!SVGBalloonRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 10/3/2005 16:19'!renderText: anSVGText on: aCanvas	"Render the given object on the canvas."	|fill textFont anchor offset trans|	trans := anSVGText transformFrom: anSVGText world.	fill := anSVGText composedFontFillStyle.	textFont := anSVGText fontToUse.	anchor := anSVGText composedStyle at: 'text-anchor'.	offset := 0@textFont ascent.	anchor  = 'middle'		ifTrue: [offset := (textFont widthOfString: anSVGText text) // 2@textFont ascent].	anchor  = 'end'		ifTrue: [offset := (textFont widthOfString: anSVGText text)@textFont ascent].	aCanvas asBalloonCanvas preserveStateDuring: [:bc|		bc copy			aaLevel: anSVGText antialiasingLevel;			drawString: anSVGText text			at: (trans transformPoint: anSVGText location) - offset			font: textFont			color: fill]! !!SVGBalloonRenderer methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:19'!styleIn: aComponent fromSVGStyle: svgStyle	"Answer a dictionary of the style parameters for the given svg style dictionary."	|balloonStyle textStyle regenFill|	regenFill := false.	balloonStyle := aComponent composedStyle.	(svgStyle includesKey: 'font-size')		ifTrue: [balloonStyle at: 'font-size' put: (svgStyle at: 'font-size')]		ifFalse: [(balloonStyle includesKey: 'font-size')				ifFalse: [balloonStyle at: 'font-size' put: 12]].	(svgStyle includesKey: 'font-family')		ifTrue: [textStyle := TextStyle named: (svgStyle at: 'font-family').				textStyle isNil ifTrue: [textStyle := TextStyle default].				balloonStyle at: 'font' put: (textStyle fontOfSize: (balloonStyle at: 'font-size'))]		ifFalse: [(balloonStyle includesKey: 'font')				ifFalse: [balloonStyle at: 'font' put: TextStyle defaultFont]].	(svgStyle includesKey: 'text-anchor')		ifTrue: [balloonStyle at: 'text-anchor' put: (svgStyle at: 'text-anchor')]		ifFalse: [(balloonStyle includesKey: 'text-anchor')				ifFalse: [balloonStyle at: 'text-anchor' put: 'start']].	(svgStyle includesKey: 'opacity')		ifTrue: [balloonStyle at: 'opacity' put: (svgStyle at: 'opacity').				regenFill := true.]		ifFalse: [(balloonStyle includesKey: 'opacity')				ifFalse: [balloonStyle at: 'opacity' put: 1.0]].	(svgStyle includesKey: 'fill-opacity')		ifTrue: [balloonStyle at: 'fill-opacity' put: (svgStyle at: 'fill-opacity').				regenFill := true]		ifFalse: [(balloonStyle includesKey: 'fill-opacity')				ifFalse: [balloonStyle at: 'fill-opacity' put: 1.0]].	(svgStyle includesKey: 'fill')		ifTrue: [balloonStyle at: 'fill' put: (svgStyle at: 'fill').				regenFill := true]		ifFalse: [(balloonStyle includesKey: 'fill')				ifFalse: [balloonStyle at: 'fill' put: Color transparent]].	regenFill 		ifTrue: [balloonStyle at: 'fill' put: ((balloonStyle at: 'fill')					alphaMixed: (balloonStyle at: 'fill-opacity') * (balloonStyle at: 'opacity'))].	(svgStyle includesKey: 'fill-rule')		ifTrue: [balloonStyle at: 'fill-rule' put: (svgStyle at: 'fill-rule')]		ifFalse: [(balloonStyle includesKey: 'fill-rule')				ifFalse: [balloonStyle at: 'fill-rule' put: 'nonzero']].	(svgStyle includesKey: 'stroke-width')		ifTrue: [balloonStyle at: 'stroke-width' put: (svgStyle at: 'stroke-width')]		ifFalse: [(balloonStyle includesKey: 'stroke-width')				ifFalse: [balloonStyle at: 'stroke-width' put: 1]].	(svgStyle includesKey: 'stroke-linecap')		ifTrue: [balloonStyle at: 'stroke-linecap' put: (svgStyle at: 'stroke-linecap')]		ifFalse: [(balloonStyle includesKey: 'stroke-linecap')				ifFalse: [balloonStyle at: 'stroke-linecap' put: #square]].	(svgStyle includesKey: 'stroke-opacity')		ifTrue: [balloonStyle at: 'stroke-opacity' put: (svgStyle at: 'stroke-opacity')]		ifFalse: [(balloonStyle includesKey: 'stroke-opacity')				ifFalse: [balloonStyle at: 'stroke-opacity' put: 1.0]].	(svgStyle includesKey: 'stroke')		ifTrue: [balloonStyle at: 'stroke' put: ((svgStyle at: 'stroke')				alphaMixed: (balloonStyle at: 'stroke-opacity') * (balloonStyle at: 'opacity'))]		ifFalse: [(balloonStyle includesKey: 'stroke')				ifFalse: [balloonStyle at: 'stroke' put: Color transparent]].	(svgStyle includesKey: 'display')		ifTrue: [balloonStyle at: 'display' put: ((svgStyle at: 'display') withBlanksTrimmed ~= 'none')]		ifFalse: [(balloonStyle includesKey: 'display')				ifFalse: [balloonStyle at: 'display' put: true]].	(svgStyle includesKey: 'visibility')		ifTrue: [balloonStyle at: 'visibility' put: ((svgStyle at: 'visibility') withBlanksTrimmed = 'visible')]		ifFalse: [(balloonStyle includesKey: 'visibility')				ifFalse: [balloonStyle at: 'visibility' put: true]].	(balloonStyle at: 'stroke') isColor		ifTrue: [(balloonStyle at: 'stroke') isTransparent			ifTrue: [balloonStyle at: 'stroke-width' put: 0]			ifFalse: [balloonStyle at: 'stroke' put: ((balloonStyle at: 'stroke') alpha: (balloonStyle at: 'stroke-opacity'))]]		ifFalse: [].	^balloonStyle ! !Object subclass: #SVGSegmentRun	instanceVariableNames: 'segments'	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGSegmentRun methodsFor: 'accessing' stamp: 'gvc 10/25/2005 13:05'!add: aRun	"Add the run to the receiver."	self segments addAll: aRun segments! !!SVGSegmentRun methodsFor: 'accessing' stamp: 'gvc 10/25/2005 12:50'!initialize	"Initialize the receiver."	super initialize.	self segments: OrderedCollection new! !!SVGSegmentRun methodsFor: 'accessing' stamp: 'gvc 10/25/2005 12:32'!segments	"Answer the value of segments"	^ segments! !!SVGSegmentRun methodsFor: 'accessing' stamp: 'gvc 10/25/2005 12:32'!segments: anObject	"Set the value of segments"	segments _ anObject! !!SVGSegmentRun methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 13:21'!points	"Answer the points describing the receiver's segments."	self subclassResponsibility! !!SVGSegmentRun methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 12:31'!primAddToEngine: aBalloonEngine fills: fills lineWidth: lineWidth	"Add the receiver's description to the ballooon engine."	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SVGSegmentRun class	instanceVariableNames: ''!!SVGSegmentRun class methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 12:49'!runsFromSegments: aCollection	"Answer a collection of runs from the given segments."	|answer str seg run runClass position|	answer _ OrderedCollection new.	aCollection isEmpty		ifTrue: [^answer].	str _ aCollection readStream.	run  _ str next run.	runClass _ aCollection first runClass.	position _ aCollection first end.	[str atEnd] whileFalse: [		seg _ str next.		(seg runClass ~= runClass or: [seg start ~= position])			ifTrue: [answer add: run.					runClass _ seg runClass.					run _ seg run]			ifFalse: [run add: seg run].		position _ seg end].	answer add: run.	^answer		! !!SVGSegmentRun class methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 12:43'!segments: aCollection	"Answer a new instasnce of the receiver with the given segments."	^self new segments: aCollection! !SVGSegmentRun subclass: #SVGBezierSegmentRun	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGBezierSegmentRun methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 13:23'!points	"Answer the collection of points that are formed by the segments.."	|answer|	answer := OrderedCollection new: self segments size * 3.	self segments do: [:s |		answer			add: s start;			add: s via;			add: s end].	^answer asArray! !!SVGBezierSegmentRun methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 12:53'!primAddToEngine: aBalloonEngine fills: fills lineWidth: lineWidth	"Add the receiver's description to the ballooon engine."	aBalloonEngine		primAddBezierShape: self points		segments: self segments size		fill: (fills at: 1)		lineWidth: lineWidth		lineFill: (fills at: 2)! !SVGSegmentRun subclass: #SVGLineSegmentRun	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGLineSegmentRun methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 13:23'!points	"Answer the collection of points that are formed by the segments.."	|answer|	answer := OrderedCollection new: self segments size * 2.	self segments do: [:s |		answer			add: s start;			add: s end].	^answer asArray! !!SVGLineSegmentRun methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 13:44'!primAddToEngine: aBalloonEngine fills: fills lineWidth: lineWidth	"Add the receiver's description to the ballooon engine."	aBalloonEngine		primAddPolygon: self points		segments: self segments size * 2		fill: (fills at: 1)		lineWidth: lineWidth		lineFill: (fills at: 2)! !SVGLineSegmentRun subclass: #SVGFixupLineSegmentRun	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGFixupLineSegmentRun methodsFor: 'as yet unclassified' stamp: 'gvc 10/25/2005 13:44'!primAddToEngine: aBalloonEngine fills: fills lineWidth: lineWidth	"Add the receiver's description to the ballooon engine."	aBalloonEngine		primAddPolygon: self points		segments: self segments size * 2		fill: (fills at: 1)		lineWidth: 1		lineFill: 0! !SVGCompositeMorph subclass: #SVGTextMorph	instanceVariableNames: 'text location'	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGTextMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 11:17'!createFromSVG: anElement	"Create a text from the svg text."	self createTextFromSVG: anElement.	super createFromSVG: anElement! !!SVGTextMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 11:12'!createTSpanFromSVGTSpan: anElement	"Create a text from the svg text."	^self create: SVGTSpanMorph fromSVG: anElement! !!SVGTextMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:10'!createTextFromSVG: anElement	"Create the text from the svg text.	Doen't handle tspans yet!!"	self text: anElement characterData.	self location: (anElement attributeAt: 'x' ifAbsent: [0]) asSVGNumber@(anElement attributeAt: 'y' ifAbsent: [0]) asSVGNumber! !!SVGTextMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:06'!drawOn: aCanvas	"Draw the component on the canvas."		(self composedStyle at: 'visibility')		ifFalse: [^self].	super drawOn: aCanvas.	self renderer		renderText: self		on: aCanvas! !!SVGTextMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/31/2005 09:37'!fontToUse	"Answer the font to be used at this time.	Strike fonts should come up with the nearest size to that required,	TT fonts should be better!!"	|fontSize textFont trans ptSize|	trans := self transformFrom: self world.	fontSize := (self composedStyle at: 'font-size').	textFont := self composedStyle at: 'font'.	ptSize := (trans transformDirection: fontSize@0) x rounded - 1 max: 1.	"textFont := TTCFontSet familyName: textFont familyName pointSize:  ptSize."	textFont isTTCFont		ifTrue: [textFont := (TextStyle named: textFont familyName) addNewFontSize: ptSize]		ifFalse: [textFont := (TextStyle named: textFont familyName) fontOfSize: ptSize].	^textFont! !!SVGTextMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 11:15'!processSVGElements: anElement	"Process the elements of the given text type element."	anElement tagsNamed: #tspan do: [:e |		self createTSpanFromSVGTSpan: e]! !!SVGTextMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2005 19:42'!userSpaceBoundingBoxWithRespectTo: aComposite	"Answer the bounding box of the receiver with respect to the transforms	intervening between the receiver and aComposite."	|fontSize textFont anchor offset ptSize trans|	trans _ self transformFrom: aComposite.	fontSize := (self composedStyle at: 'font-size').	textFont := self composedStyle at: 'font'.	ptSize := (trans transformDirection: fontSize@0) x rounded - 1 max: 1.	textFont := TTCFontSet familyName: textFont familyName pointSize:  ptSize.	anchor := self composedStyle at: 'text-anchor'.	offset := 0@textFont ascent.	anchor  = 'middle'		ifTrue: [offset := (textFont widthOfString: self text) // 2@textFont ascent].	anchor  = 'end'		ifTrue: [offset := (textFont widthOfString: self text)@textFont ascent].	^(trans transformPoint: self location) - offset extent: (textFont widthOfString: self text)@textFont height! !!SVGTextMorph methodsFor: 'accessing' stamp: 'gvc 7/30/2005 10:34'!location	"Answer the value of location"	^ location! !!SVGTextMorph methodsFor: 'accessing' stamp: 'gvc 7/30/2005 10:34'!location: anObject	"Set the value of location"	location _ anObject! !!SVGTextMorph methodsFor: 'accessing' stamp: 'gvc 7/30/2005 10:29'!text	"Answer the value of text"	^ text! !!SVGTextMorph methodsFor: 'accessing' stamp: 'gvc 7/30/2005 10:29'!text: anObject	"Set the value of text"	text _ anObject! !SVGTextMorph subclass: #SVGTSpanMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SVG-Morphic'!!SVGTSpanMorph methodsFor: 'as yet unclassified' stamp: 'gvc 10/4/2005 09:10'!createTextFromSVG: anElement	"Create the text from the svg text."	super createTextFromSVG: anElement.	self location:		(anElement attributeAt: 'x' ifAbsent: [self owner location x]) asSVGNumber @		(anElement attributeAt: 'y' ifAbsent: [self owner location y]) asSVGNumber! !!SVGTSpanMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/1/2005 11:15'!processSVGElements: anElement	"Process the elements of the given tspan type element.	Do nothing for this."! !