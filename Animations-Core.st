Object subclass: #AnimAnimation	instanceVariableNames: 'deletionPolicy direction state currentLoop currentTime duration loopCount startTime pauseDuration resetAfterFinished finishedOnce finishBlock'	classVariableNames: 'ReferenceTime'	poolDictionaries: ''	category: 'Animations-Core'!!AnimAnimation commentStamp: 'mt 6/30/2011 09:59:07.207' prior: 0!I am the abstract base class for all kinds of animations. If you use me with the world's #lastCycleTime all time, durations a.s.o. should be considered in milliseconds.I emit the following changed-signals:#finished ... The animation is done, e.g., after all loops are played.#stateChanged ... Whenever the state of this animation changes. See #state:. The arguments containt the old and the new one.#currentLoopChanged ... Whenever #currentLoop changes. Contains the current loop number.#directionChanged ... Whenever #direction changes. Contains the new direction.Animations use a custom ReferenceTime as "WorldState lastCycleTime" does not work for busy cycles.Note: This is some kind of a Squeak port of the Nokia Qt 4.6 Animation Framework.!!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 10:32:58.926'!currentLoop	^ currentLoop ifNil: [currentLoop := 1]! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 10:47:03.583'!currentLoopTime	"Return the current time inside the current loop. Starts at 0 and ends at #duration."		^ self currentTime \\ self duration! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 10:32:39.8'!currentTime	"The current time starts at 0 and ends at #totalDuration."	^ currentTime ifNil: [currentTime := 0]! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 09:12:27.466'!currentTime: anInteger	currentTime := anInteger.! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 10:32:27.874'!direction	^ direction ifNil: [direction := #forward]! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/14/2010 11:23:30.9'!direction: aDirection	"#forward, #backward"		aDirection ~=  direction ifTrue: [		direction := aDirection.		self changed: #directionChanged with: {aDirection}].! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 11:10:27.148'!duration	^ duration ifNil: [Error signal: 'Animation duration was not set!!']! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/17/2010 14:14:05.399'!finishBlock		^ finishBlock ifNil: [[]]! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/17/2010 14:13:38.918'!finishBlock: aBlock	"This block will be evaluated on finish."		finishBlock := aBlock.! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/14/2010 20:17:01.832'!finishedOnce	"This flag is primarily used by the animation registry to perform garbage collection."	^ finishedOnce ifNil: [finishedOnce := false]! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 09:36:21.713'!loopCount	^ loopCount ifNil: [loopCount := 1]! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 09:42:34.762'!loopCount: anInteger	"Define how often the animation will be played.		0 ... not played at all	n ... run animation n times (default: 1)	-1 ... run animation forever"	loopCount := anInteger.! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 10:50:47.79'!resetAfterFinished	^ resetAfterFinished ifNil: [resetAfterFinished := false]! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 10:51:47.207'!resetAfterFinished: aBoolean	"Set the animation to the beginning after it has ended. Is not used for infinite loops."	resetAfterFinished := aBoolean.! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 10:31:26.03'!state	^ state ifNil: [state := #stopped]! !!AnimAnimation methodsFor: 'accessing' stamp: 'mt 5/12/2010 09:33:30.059'!totalDuration	^ self duration * self loopCount! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/14/2010 11:00:46.441'!currentLoop: anInteger	currentLoop ~= anInteger ifTrue: [		currentLoop := anInteger.		self changed: #currentLoopChanged with: currentLoop].! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/14/2010 20:25:08.059'!deletionPolicy	^ deletionPolicy ifNil: [deletionPolicy := #deleteWhenFinished]! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/14/2010 20:06:36.475'!deletionPolicy: aPolicy	"#keepWhenFinished, #deleteWhenFinished"		deletionPolicy := aPolicy.! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/12/2010 09:17:29.683'!duration: anInteger	duration := anInteger.! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/14/2010 20:16:04.971'!finishedOnce: aBoolean	finishedOnce := aBoolean.! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/12/2010 10:21:00.008'!pauseDuration	^ pauseDuration ifNil: [pauseDuration := 0]! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/12/2010 10:21:32.48'!pauseDuration: anInteger	"Define that part of the time that should be ignored."	pauseDuration := anInteger.! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/12/2010 09:55:04.048'!startTime	^ startTime! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/12/2010 09:54:55.696'!startTime: anInteger	"Used to calculate everything."	startTime := anInteger.! !!AnimAnimation methodsFor: 'accessing - private' stamp: 'mt 5/12/2010 10:02:57.196'!state: aState	"#stopped, #paused, #running"		aState ~= state ifTrue: [		| oldState |		oldState := state.		state := aState.		self changed: #stateChanged with: {oldState. aState}].! !!AnimAnimation methodsFor: 'control - private' stamp: 'mt 5/17/2010 14:13:55.713'!finish	self stop.		self resetAfterFinished		ifTrue: [self toStart]		ifFalse: [self toEnd].			self		finishedOnce: true;		changed: #finished.			self finishBlock value.! !!AnimAnimation methodsFor: 'control - private' stamp: 'mt 5/15/2010 18:23:43.585'!reset	self		toStart;		finishedOnce: false;		startTime: nil.! !!AnimAnimation methodsFor: 'control - private' stamp: 'mt 5/15/2010 18:23:31.947'!toEnd	self		currentLoop: (self loopCount max: 1);		currentTime: (self duration * self loopCount) - 1;		pauseDuration: 0.! !!AnimAnimation methodsFor: 'control - private' stamp: 'mt 5/15/2010 18:23:20.861'!toStart	self		currentLoop: 1;		currentTime: 0;		pauseDuration: 0.! !!AnimAnimation methodsFor: 'testing' stamp: 'mt 5/14/2010 19:31:37.335'!isGraphicsAnimation	^ false! !!AnimAnimation methodsFor: 'testing' stamp: 'mt 5/12/2010 10:10:10.919'!isInfinite	^ self loopCount = -1! !!AnimAnimation methodsFor: 'testing' stamp: 'mt 5/12/2010 09:53:32.112'!isPaused	^ self state = #paused! !!AnimAnimation methodsFor: 'testing' stamp: 'mt 5/14/2010 19:31:43.761'!isPropertyAnimation	^ false! !!AnimAnimation methodsFor: 'testing' stamp: 'mt 5/12/2010 09:53:29.451'!isRunning	^ self state = #running! !!AnimAnimation methodsFor: 'testing' stamp: 'mt 5/12/2010 09:53:26.603'!isStopped	^ self state = #stopped! !!AnimAnimation methodsFor: 'control' stamp: 'mt 5/12/2010 10:35:33.769'!pause	"This will pause the animation. #currentTime remains unchanged until #start or #resume is called."		self isRunning ifTrue: [		self state: #paused].! !!AnimAnimation methodsFor: 'control' stamp: 'mt 5/12/2010 10:35:49.11'!resume	"Resumes a paused animation."		self isPaused ifTrue: [		self state: #running].! !!AnimAnimation methodsFor: 'control' stamp: 'mt 5/17/2010 07:45:52.436'!reverse	self direction = #forward		ifTrue: [self direction: #backward]		ifFalse: [self direction: #forward].! !!AnimAnimation methodsFor: 'control' stamp: 'mt 5/15/2010 18:00:37.484'!start		self start: #keepWhenFinished.! !!AnimAnimation methodsFor: 'control' stamp: 'mt 5/15/2010 18:00:22.499'!start: aDeletionPolicy	"If the animation is paused or stopped the animation will be rewinded and start from the beginning. If the animation is running, nothing will happen."		self isRunning ifFalse: [		self			deletionPolicy: aDeletionPolicy;			reset;			state: #running].! !!AnimAnimation methodsFor: 'control' stamp: 'mt 5/12/2010 12:03:11.694'!stop	self		state: #stopped;		toStart.! !!AnimAnimation methodsFor: 'registering' stamp: 'mt 6/7/2010 15:25:44.801'!register	AnimAnimationRegistry main register: self.! !!AnimAnimation methodsFor: 'registering' stamp: 'mt 6/7/2010 15:25:44.876'!unregister	AnimAnimationRegistry main unregister: self.! !!AnimAnimation methodsFor: 'updating - private' stamp: 'mt 5/14/2010 11:30:33.798'!updateCurrentLoop	"Detect loop end and change."		(self currentTime // self duration) >= self currentLoop		ifTrue: [self currentLoop: (self currentTime // self duration) + 1].! !!AnimAnimation methodsFor: 'updating - private' stamp: 'mt 5/12/2010 10:55:07.045'!updateState	self isInfinite		ifTrue: [^ self].		self currentLoop > self loopCount		ifTrue: [self finish]! !!AnimAnimation methodsFor: 'updating' stamp: 'mt 6/30/2011 10:00:25.199'!updateCurrentTime	self updateCurrentTime: ReferenceTime.! !!AnimAnimation methodsFor: 'updating' stamp: 'mt 5/12/2010 11:58:10.017'!updateCurrentTime: referenceTime	"This should be called frequently to keep the animation running."	self isStopped ifTrue: [^ self].		"Set an accurate start time in the first update cycle."	self startTime ifNil: [		self startTime: referenceTime].	self isRunning ifTrue: [		self			currentTime: (referenceTime - self startTime) - self pauseDuration;			updateCurrentLoop;			updateState].			self isPaused ifTrue: [		self pauseDuration: (referenceTime - self startTime) - self currentTime].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AnimAnimation class	instanceVariableNames: ''!!AnimAnimation class methodsFor: 'time' stamp: 'mt 6/30/2011 09:57:44.885'!updateReferenceTime	ReferenceTime := Time millisecondClockValue.! !Object subclass: #AnimAnimationRegistry	instanceVariableNames: 'propertyAnimations graphicsAnimations mutex lastGCTime'	classVariableNames: ''	poolDictionaries: ''	category: 'Animations-Core'!!AnimAnimationRegistry commentStamp: 'mt 5/17/2010 15:48:31.878' prior: 0!Should be thread-safe.!!AnimAnimationRegistry methodsFor: 'queries' stamp: 'mt 5/17/2010 15:46:38.126'!animationsFor: anObject	self mutex critical: [		^ (self graphicsAnimations select: [:anim | anim morph = anObject]),			(self propertyAnimations select: [:anim | anim target = anObject])].! !!AnimAnimationRegistry methodsFor: 'queries' stamp: 'mt 5/3/2011 11:22:28.201'!displayFPS	(Smalltalk includesKey: #frameCountStartTime)		ifFalse: [Smalltalk at: #frameCountStartTime put: WorldState lastCycleTime].	(Smalltalk includesKey: #currentFrameCount)		ifFalse: [Smalltalk at: #currentFrameCount put: 0].	(Smalltalk includesKey: #lastFPS)		ifFalse: [Smalltalk at: #lastFPS put: 0].	(WorldState lastCycleTime - (Smalltalk at: #frameCountStartTime)) < 0		ifTrue: [			Smalltalk at: #frameCountStartTime put: WorldState lastCycleTime].	(WorldState lastCycleTime - (Smalltalk at: #frameCountStartTime)) > 1000		ifTrue: [			Smalltalk				at: #lastFPS put: (Smalltalk at: #currentFrameCount);				at: #currentFrameCount put: 0;				at: #frameCountStartTime put: WorldState lastCycleTime].				Smalltalk at: #currentFrameCount put: (Smalltalk at: #currentFrameCount) + 1.	(Smalltalk at: #lastFPS) asString, ' FPS' displayAt: 0@18.! !!AnimAnimationRegistry methodsFor: 'queries' stamp: 'mt 4/22/2011 11:52:48.105'!isAtLeastOneGraphicsAnimationRunningFor: aMorph	"Use this query to schedule redraw operations."		^ aMorph animations anySatisfy: [:anim | anim isRunning]! !!AnimAnimationRegistry methodsFor: 'queries' stamp: 'mt 4/22/2011 11:53:38.36'!transformedCanvasFor: aMorph from: aCanvas	| transformedCanvas |	transformedCanvas := aCanvas.	aMorph animations do: [:anim |		transformedCanvas := anim transformedCanvas: transformedCanvas].	^ transformedCanvas! !!AnimAnimationRegistry methodsFor: 'registering' stamp: 'mt 4/22/2011 11:51:54.289'!clear	self mutex critical: [		"Clear local animation caches."		self graphicsAnimations do: [:anim |			anim morph ifNotNil: [:m | m removeProperty: #animations]].				propertyAnimations := nil.		graphicsAnimations := nil].! !!AnimAnimationRegistry methodsFor: 'registering' stamp: 'mt 4/22/2011 11:49:15.402'!register: anAnimation	self mutex critical: [		anAnimation isPropertyAnimation			ifTrue: [self propertyAnimations add: anAnimation].				anAnimation isGraphicsAnimation			ifTrue: [				self graphicsAnimations add: anAnimation.				anAnimation morph ifNotNil: [:m |					m animations add: anAnimation.					m redrawLater]]].! !!AnimAnimationRegistry methodsFor: 'registering' stamp: 'mt 4/22/2011 11:50:03.298'!unregister: anAnimation	self mutex critical: [		anAnimation isPropertyAnimation			ifTrue: [self propertyAnimations remove: anAnimation ifAbsent: []].				anAnimation isGraphicsAnimation			ifTrue: [				self graphicsAnimations remove: anAnimation ifAbsent: [].				anAnimation morph ifNotNil: [:m | m animations remove: anAnimation]]].! !!AnimAnimationRegistry methodsFor: 'updating - private' stamp: 'mt 6/16/2010 12:03:28.468'!garbageCollect	self propertyAnimations		select: [:anim | anim target isNil or: [anim finishedOnce and: [anim deletionPolicy = #deleteWhenFinished]]]		thenDo: [:anim | anim unregister].			self graphicsAnimations		select: [:anim | anim morph isNil or: [anim finishedOnce and: [anim deletionPolicy = #deleteWhenFinished]]]		thenDo: [:anim | anim unregister].! !!AnimAnimationRegistry methodsFor: 'updating - private' stamp: 'mt 3/29/2011 09:21:29.854'!tryGarbageCollect	| interval |	interval := lastGCTime		ifNil: [5000]		ifNotNil: [:t | (t to: DateAndTime now) duration asMilliSeconds].		interval < 0		ifTrue: [interval := 5000].		interval < 5000		ifTrue: [^ self].			self mutex critical: [self garbageCollect].		lastGCTime := DateAndTime now.! !!AnimAnimationRegistry methodsFor: 'updating - private' stamp: 'mt 5/14/2010 19:39:30.576'!updateCurrentTime	"Updates the reference time for each registered animation."		self propertyAnimations do: [:anim | anim updateCurrentTime].	self graphicsAnimations do: [:anim | anim updateCurrentTime].! !!AnimAnimationRegistry methodsFor: 'updating - private' stamp: 'mt 5/3/2011 13:23:37.536'!updateCurrentValues		self propertyAnimations do: [:anim |		anim updateCurrentValue.		"GC here too. Needs mutex?"		(anim target isNil or: [anim finishedOnce and: [anim deletionPolicy = #deleteWhenFinished]])			ifTrue: [anim unregister]].! !!AnimAnimationRegistry methodsFor: 'accessing - private' stamp: 'mt 5/14/2010 19:34:30.155'!graphicsAnimations	^ graphicsAnimations ifNil: [graphicsAnimations := OrderedCollection new]! !!AnimAnimationRegistry methodsFor: 'accessing - private' stamp: 'mt 5/17/2010 15:40:56.495'!mutex	^ mutex ifNil: [mutex := Mutex new]! !!AnimAnimationRegistry methodsFor: 'accessing - private' stamp: 'mt 5/14/2010 19:34:13.507'!propertyAnimations	^ propertyAnimations ifNil: [propertyAnimations := OrderedCollection new]! !!AnimAnimationRegistry methodsFor: 'updating' stamp: 'mt 4/22/2011 11:55:10.654'!updateAnimations	self mutex critical: [[		self			updateCurrentTime;			updateCurrentValues.	] on: Error do: [:error | self clear. Error signal: 'There was an error in the animation framework. All animations were stopped']].	self tryGarbageCollect.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AnimAnimationRegistry class	instanceVariableNames: 'instance morphicDrawBlock'!!AnimAnimationRegistry class methodsFor: 'instance creation' stamp: 'mt 5/14/2010 19:36:29.412'!main	"Return the main registry for animations that is queried in each world cycle."		^ instance ifNil: [instance := self new]! !!AnimAnimationRegistry class methodsFor: 'instance creation' stamp: 'mt 6/16/2010 12:08:25.188'!reset		instance := nil.! !!AnimAnimationRegistry class methodsFor: 'accessing' stamp: 'mt 5/4/2011 15:24:55.956'!morphicDrawBlock	"Draw the full Morphic structure on the given Canvas."		^ morphicDrawBlock ifNil: [morphicDrawBlock := [:morph :canvas |			morph fullDrawOnReally: canvas.]].! !!AnimAnimationRegistry class methodsFor: 'accessing' stamp: 'mt 5/4/2011 15:18:03.063'!morphicDrawBlock: aBlock	"Set a new piece of code that is called in #fullDrawOn: given a morph and a canvas."	morphicDrawBlock := aBlock.! !Object subclass: #AnimEasingCurve	instanceVariableNames: 'type conversionBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Animations-Core'!!AnimEasingCurve commentStamp: 'mt 5/14/2010 19:28:46.069' prior: 0!I am capable of defining the velocity for the interpolation of an XpfVariantAnimation.!!AnimEasingCurve methodsFor: 'accessing' stamp: 'mt 5/2/2011 20:19:17.89'!conversionBlock	^ conversionBlock! !!AnimEasingCurve methodsFor: 'accessing' stamp: 'mt 5/2/2011 20:19:24.179'!conversionBlock: aBlock	conversionBlock := aBlock.! !!AnimEasingCurve methodsFor: 'accessing' stamp: 'mt 5/14/2010 14:27:27.368'!type	^ type ifNil: [type := #linear]! !!AnimEasingCurve methodsFor: 'accessing' stamp: 'mt 5/2/2011 20:19:40.876'!valueForProgress: aFloat	"Interpolate the given value which should be between 0.0 and 1.0."		^ self conversionBlock		ifNil: [aFloat "just linear now"]		ifNotNil: [:b | b value: aFloat]! !!AnimEasingCurve methodsFor: 'testing' stamp: 'mt 5/14/2010 19:29:07.001'!isLinear	^ self type = #linear! !!AnimEasingCurve methodsFor: 'accessing - private' stamp: 'mt 5/14/2010 19:29:25.902'!type: aType	"Possible values: #linear."		type := aType.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AnimEasingCurve class	instanceVariableNames: ''!!AnimEasingCurve class methodsFor: 'instance creation' stamp: 'mt 5/14/2010 14:29:14.198'!linear	^ self new		type: #linear! !AnimAnimation subclass: #AnimVariantAnimation	instanceVariableNames: 'easingCurve startValue endValue offset offsetBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Animations-Core'!!AnimVariantAnimation commentStamp: 'mt 5/14/2010 14:43:20.077' prior: 0!I extend the abstract animation with some value interpolation behaviour (besides the time). You can keep me running by calling #updateCurrentTime and #updateCurrentValue frequently.!!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/17/2010 17:23:21.929'!currentValue	| v o |	v := self		interpolatedFrom: self startValue		to: self endValue		progress: self currentLoopTime asFloat / ((self duration - 1) max: 1).	o := self offset.		^ o		ifNil: [v]		ifNotNil: [v + o]! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 6/7/2010 15:27:00.533'!easingCurve	^ easingCurve ifNil: [easingCurve := AnimEasingCurve new]! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/14/2010 12:42:22.17'!easingCurve: anEasingCurve	easingCurve := anEasingCurve.! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/14/2010 12:29:23.688'!endValue	^ endValue! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/14/2010 12:29:15.244'!endValue: anObject	endValue := anObject.! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/17/2010 17:21:52.712'!offset		^ self offsetBlock		ifNotNil: [self offsetBlock value]		ifNil: [offset]! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/17/2010 17:20:18.206'!offset: aValue	offset := aValue.! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/17/2010 17:20:55.789'!offsetBlock		^ offsetBlock! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/17/2010 17:21:26.062'!offsetBlock: aBlock	"Will be used to calculate the offset dynamically. See #offset."		offsetBlock := aBlock.! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/14/2010 12:29:04.466'!startValue	^ startValue! !!AnimVariantAnimation methodsFor: 'accessing' stamp: 'mt 5/14/2010 12:28:54.496'!startValue: anObject	startValue := anObject.! !!AnimVariantAnimation methodsFor: 'interpolating' stamp: 'mt 5/14/2010 16:53:16.721'!interpolatedFrom: fromValue to: toValue progress: aFloat	"Assumes simple numbers at the moment. Maybe a more complex interpolator could make other types possible."	^ fromValue + ((toValue - fromValue) *		(self direction = #backward			ifTrue: [1.0 - (self easingCurve valueForProgress: aFloat)]			ifFalse: [self easingCurve valueForProgress: aFloat]))! !!AnimVariantAnimation methodsFor: 'updating' stamp: 'mt 5/14/2010 14:42:02.972'!updateCurrentValue	self updateCurrentValue: self currentValue.! !!AnimVariantAnimation methodsFor: 'updating' stamp: 'mt 5/14/2010 12:40:20.228'!updateCurrentValue: aValue	self subclassResponsibility.! !AnimVariantAnimation subclass: #AnimGraphicsAnimation	instanceVariableNames: 'morph'	classVariableNames: ''	poolDictionaries: ''	category: 'Animations-Core'!!AnimGraphicsAnimation commentStamp: 'mt 5/14/2010 16:44:02.071' prior: 0!I am capable of graphic effects, e.g., fade-in or fade-out.!!AnimGraphicsAnimation methodsFor: 'testing' stamp: 'mt 5/14/2010 19:32:07.36'!isGraphicsAnimation	^ true! !!AnimGraphicsAnimation methodsFor: 'accessing' stamp: 'mt 6/16/2010 11:54:53.963'!morph	morph ifNil: [morph := WeakArray new: 1].			^ morph at: 1.! !!AnimGraphicsAnimation methodsFor: 'accessing' stamp: 'mt 6/16/2010 12:04:40.875'!morph: aMorph	morph ifNil: [morph := WeakArray new: 1].	morph at: 1 put: aMorph.! !!AnimGraphicsAnimation methodsFor: 'accessing' stamp: 'mt 5/17/2010 14:21:57.388'!type	^ #graphics! !!AnimGraphicsAnimation methodsFor: 'updating - private' stamp: 'mt 6/16/2010 12:00:37.275'!repaint	self morph ifNil: [^ self].	self morph redrawLater.! !!AnimGraphicsAnimation methodsFor: 'control' stamp: 'mt 5/15/2010 18:16:21.399'!resume	super resume.	self repaint.! !!AnimGraphicsAnimation methodsFor: 'control' stamp: 'mt 5/15/2010 18:16:15.412'!start	super start.	self repaint.! !!AnimGraphicsAnimation methodsFor: 'control' stamp: 'mt 5/15/2010 18:18:31.869'!stop	super stop.	self repaint.! !!AnimGraphicsAnimation methodsFor: 'interpolating' stamp: 'mt 5/14/2010 18:51:16.154'!transformedCanvas: aCanvas	self subclassResponsibility.! !!AnimGraphicsAnimation methodsFor: 'updating' stamp: 'mt 5/14/2010 16:49:13.97'!updateCurrentValue: aValue	"Do nothing here."	! !AnimVariantAnimation subclass: #AnimPropertyAnimation	instanceVariableNames: 'target property'	classVariableNames: ''	poolDictionaries: ''	category: 'Animations-Core'!!AnimPropertyAnimation methodsFor: 'testing' stamp: 'mt 5/14/2010 19:31:56.258'!isPropertyAnimation	^ true! !!AnimPropertyAnimation methodsFor: 'accessing' stamp: 'mt 5/14/2010 14:48:24.768'!property	^ property! !!AnimPropertyAnimation methodsFor: 'accessing' stamp: 'mt 5/14/2010 16:34:33.236'!property: aProperty	property := aProperty.! !!AnimPropertyAnimation methodsFor: 'accessing' stamp: 'mt 6/16/2010 11:55:40.521'!target	target ifNil: [target := WeakArray new: 1].			^ target at: 1.! !!AnimPropertyAnimation methodsFor: 'accessing' stamp: 'mt 6/16/2010 12:04:51.334'!target: anObject	target ifNil: [target := WeakArray new: 1].	target at: 1 put: anObject.! !!AnimPropertyAnimation methodsFor: 'updating' stamp: 'mt 6/16/2010 11:56:26.322'!updateCurrentValue: aValue	self target ifNil: [^ self].		self target		perform: (self property, #:) asSymbol		with: aValue.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AnimPropertyAnimation class	instanceVariableNames: ''!!AnimPropertyAnimation class methodsFor: 'examples' stamp: 'mt 6/16/2010 10:39:35.692'!example1	| morph |	morph := Morph new		position: 50@50;		extent: 100@100.	morph addMorph: (Morph new		position: 60@60;		extent: 80@80;		color: Color yellow).		(AnimPropertyAnimation on: morph property: #position start: (50@50) end: (400@400) duration: 500)		register;		start: #deleteWhenFinished.			morph openInWorld.! !!AnimPropertyAnimation class methodsFor: 'instance creation' stamp: 'mt 5/14/2010 16:34:42.775'!on: anObject property: aProperty start: aStartValue end: anEndValue duration: milliseconds	^ self new		target: anObject;		property: aProperty;		startValue: aStartValue;		endValue: anEndValue;		duration: milliseconds! !