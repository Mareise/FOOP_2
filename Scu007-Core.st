Object subclass: #ScuEventDispatcher	instanceVariableNames: 'listeners allListeners'	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuEventDispatcher commentStamp: 'Matthias Springer 2/10/2012 14:31:31.226' prior: 0!A ScuEventDispatcher is distributes events between other objects.Instance Variables	allListeners:		All objects that registered for any type of event(s).	listeners:		Mapping from event recipient to actual recipients.!!ScuEventDispatcher methodsFor: 'accessing' stamp: 'kf 2/4/2012 19:55:08.759'!allListeners	allListeners ifNil: [ self allListeners: IdentitySet new. ].	^ allListeners! !!ScuEventDispatcher methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 15:41'!allListeners: anObject	allListeners := anObject.! !!ScuEventDispatcher methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:26:19.988'!listeners	listeners ifNil: [self listeners: Dictionary new].	^ listeners! !!ScuEventDispatcher methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:25:44.464'!listeners: anObject	listeners := anObject.! !!ScuEventDispatcher methodsFor: 'accessing' stamp: 'Matthias Springer 2/9/2012 14:27:35.176'!listenersFor: aRecipient	| list |	list := IdentitySet new.	(aRecipient == #all)		ifTrue: [list addAll: self allListeners]		ifFalse: [list addAll: (self listenersRegisteredFor: aRecipient).			list addAll: (self listenersRegisteredFor: #all)].	^ list! !!ScuEventDispatcher methodsFor: 'accessing' stamp: 'Matthias Springer 2/4/2012 20:59:04.537'!listenersRegisteredFor: aRecipient	^ self listeners at: aRecipient ifAbsentPut: [OrderedCollection new]! !!ScuEventDispatcher methodsFor: 'event dispatching' stamp: 'Matthias Springer 2/10/2012 19:22'!allRecipientsSatisfy: aMessage from: aSender to: aRecipient with: aPayload	| dispatchEvent |	dispatchEvent := [:re | 		((re notifyAbout: aMessage from: aSender to: aRecipient with: aPayload) = false)			ifTrue: [^ false]].	(self listenersFor: aRecipient) do: dispatchEvent.	^ true! !!ScuEventDispatcher methodsFor: 'event dispatching' stamp: 'kf 2/4/2012 19:59:07.672'!send: aMessage from: aSender to: aRecipient with: aPayload	| responses dispatchEvent |	responses := Bag new.	dispatchEvent := [:re | responses add: (re notifyAbout: aMessage from: aSender to: aRecipient with: aPayload)].	(self listenersFor: aRecipient) do: dispatchEvent.	^ responses! !!ScuEventDispatcher methodsFor: 'registering' stamp: 'Matthias Springer 2/9/2012 15:28:36.968'!register: anObject for: aRecipient	self allListeners add: anObject.	(self listenersRegisteredFor: aRecipient) add: anObject! !!ScuEventDispatcher methodsFor: 'unregistering' stamp: 'kf 2/4/2012 19:56:30.965'!unregister: anEventListener	self allListeners remove: anEventListener ifAbsent: [].	self listeners valuesDo: [:anIdentitySet | 		anIdentitySet remove: anEventListener ifAbsent: []].	^ anEventListener! !!ScuEventDispatcher methodsFor: 'unregistering' stamp: 'Matthias Springer 1/31/2012 22:26:29.852'!unregister: anEventListener from: aRecipient	"registers an event listener to receive broadcasts"	(self listenersFor: aRecipient) remove: anEventListener ifAbsent: [].	^ anEventListener! !Morph subclass: #ScuGame	instanceVariableNames: 'state level configuration mainPlayer monsters eventDispatcher preferences actions random resources stats cheats'	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuGame commentStamp: 'Matthias Springer 2/4/2012 23:57:15.227' prior: 0!A ScuGame is the "central" game object. It keeps references to all important objects and starts the game.Instance Variables	actions:		Actions, such as #firstPlayerRight or #firstPlayerPlaceBucket.	cakeAction:		Determines what happens, if the player picks up a cake (the cake is a lie!!).	configuration:		The (single) configuration object for this game.	eventDispatcher:		The (single) event dispatcher for this game.	gameTime:		?	keys:		?	lastStepAt:		?	level:		The level for this game (basically a set of tiles).	mainPlayer:		The (single) human player for this game.	monsters:		The set of monsters for this game.	preferences:		?	random:		A random number generator.	resources:		The (single) resource manager for this game.	state:		The state this game is currently in (e.g. #building).!!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:28:34.025'!actionAt: anAction	^ self actions at: anAction ifAbsentPut: []! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:28:27.404'!actions: anObject	actions := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 18:48'!cheats	^ cheats! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 18:48'!cheats: anObject	cheats := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:28:39.032'!configuration	configuration ifNil: [self configuration: ScuConfiguration new].	^ configuration! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 15:45'!configuration: anObject	configuration := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 15:45'!eventDispatcher	eventDispatcher ifNil: [		self eventDispatcher: ScuEventDispatcher new.		self eventDispatcher register: self for: #all].	^ eventDispatcher! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:30:36.385'!eventDispatcher: anObject	eventDispatcher := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:29:14.169'!level	level ifNil: [self error: 'you need to build a level'].	^ level! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:31:51.81'!level: anObject	level := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'dominik 1/21/2012 15:04:37.834'!mainPlayer	^ mainPlayer! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:31:55.019'!mainPlayer: anObject	mainPlayer := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:29:23.898'!monsters	monsters ifNil: [self monsters: OrderedCollection new].  	^ monsters! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:32:01.603'!monsters: anObject	monsters := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:29:32.041'!preferences	preferences ifNil: [self preferences: ScuPreferences default].	^ preferences! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:32:26.116'!preferences: anObject	preferences := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:29:34.443'!random	random ifNil: [self random: Random new].	^ random! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:32:36.365'!random: anObject	random := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 15:45'!resources	resources ifNil: [ 		self resources: ScuResourceManager new.		self resources imageSize: self configuration tileSize].	^ resources! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:32:45.652'!resources: anObject	resources := anObject.! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:29:45.041'!state	^ state! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 15:45'!state: anGameState	state := anGameState.	anGameState activate.! !!ScuGame methodsFor: 'accessing' stamp: 'dominik 2/5/2012 19:18:49.629'!stats	^ stats! !!ScuGame methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 15:45'!stats: anObject	stats := anObject.! !!ScuGame methodsFor: 'event handling' stamp: 'Matthias Springer 2/10/2012 15:47'!actions	| startGame |	startGame := [self state: (ScuGameRunningState newIn: self)].	actions ifNil: [self actions: (Dictionary newFromPairs: {		#firstPlayerRight. [self mainPlayer moveTo: #east. startGame value].		#firstPlayerLeft. [self mainPlayer moveTo: #west. startGame value].		#firstPlayerUp. [self mainPlayer moveTo: #north. startGame value].		#firstPlayerDown. [self mainPlayer moveTo: #south. startGame value].		#firstPlayerPlaceBucket. [self mainPlayer placeBucket].		#firstPlayerPlacePortal. [self mainPlayer placePortal].		#pause. [ self state togglePaused].		#toggleLock. [ self sticky: self isSticky not].		#exit. [self delete] })].	^ actions! !!ScuGame methodsFor: 'event handling' stamp: 'Matthias Springer 2/10/2012 15:46'!handleDeceasedItem: anItem by: anotherItem	(anItem itemSymbol == #player)		ifTrue:  [^ self handleDeceasedPlayerItem: anItem by: anotherItem]		ifFalse: [^ self handleDeceasedNonplayerItem: anItem by: anotherItem].! !!ScuGame methodsFor: 'event handling' stamp: 'Matthias Springer 2/10/2012 15:46'!handleDeceasedNonplayerItem: anItem by: anotherItem	((self eventDispatcher allRecipientsSatisfy: #gameIsWon from: self to: #all with: nil)		and: [self state isFinished not]) ifTrue: [self state: (ScuGameWonState newIn: self)].! !!ScuGame methodsFor: 'event handling' stamp: 'msw 2/9/2012 20:55:09.625'!handleDeceasedPlayerItem: aPlayer by: anotherItem	self state isFinished ifFalse: [self state: (ScuGameOverState newIn: self)].! !!ScuGame methodsFor: 'event handling' stamp: 'Matthias Springer 1/31/2012 22:28:49.451'!handlesKeyboard: evt	^ true! !!ScuGame methodsFor: 'event handling' stamp: 'Matthias Springer 1/31/2012 22:28:51.36'!handlesMouseOver: evt	^ true! !!ScuGame methodsFor: 'event handling' stamp: 'Matthias Springer 1/31/2012 22:28:53.647'!hasFocus 	^ true! !!ScuGame methodsFor: 'event handling' stamp: 'Matthias Springer 1/31/2012 13:31:37.626'!keyStroke: anEvent  	(self actionAt: (self preferences actionOn: anEvent keyCharacter)) value.! !!ScuGame methodsFor: 'event handling' stamp: 'dominik 12/9/2011 18:37:23.482'!mouseEnter: evt	ActiveHand newKeyboardFocus: self.! !!ScuGame methodsFor: 'event handling' stamp: 'Matthias Springer 2/10/2012 15:47'!notifyAbout: aMessage from: aSender to: aRecipient with: aPayload	(aMessage == #deceased) ifTrue: [^ self handleDeceasedItem: aSender by: aPayload].	^ nil! !!ScuGame methodsFor: 'event handling' stamp: 'kf 2/4/2012 18:51:27.207'!send: aMessage to: aRecipient with: aPayload	^ self eventDispatcher send: aMessage from: self to: aRecipient with: aPayload! !!ScuGame methodsFor: 'initialize-release' stamp: 'Matthias Springer 2/10/2012 18:50'!delete	self cheats ifNotNil: [self cheats delete].	^ super delete.! !!ScuGame methodsFor: 'initialize-release' stamp: 'msw 2/9/2012 16:08:32.391'!initialize	super initialize.	self sticky: true.	self color: Color transparent.	self configuration draw ifTrue: [ self state: (ScuGameConfigState newIn: self)].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScuGame class	instanceVariableNames: ''!!ScuGame class methodsFor: 'parts bin' stamp: 'Matthias Springer 2/10/2012 19:23'!descriptionForPartsBin	^ self partName: 'SpaceCleanUp' 			categories: #('SWA11') 			documentation: 'Magnificent Bomberman, Pacman and Portals clone.', 				Character cr, ' Free the spaceship but be careful. The cake is a lie!!.'			sampleImageForm: (ScuResourceManager new formFor: #player).! !!ScuGame class methodsFor: 'parts bin' stamp: 'dominik 2/5/2012 18:01:08.269'!initializeToStandAlone	super initializeToStandAlone.	self initialize.! !!ScuGame class methodsFor: 'parts bin' stamp: 'dominik 2/4/2012 18:24:55.436'!newStandAlone	^ self basicNew initializeToStandAlone! !!ScuGame class methodsFor: 'class initialization' stamp: 'Malte Swart 1/5/2012 16:34:49.994'!initialize	super initialize.	self install.! !!ScuGame class methodsFor: 'world menu' stamp: 'Matthias Springer 1/31/2012 22:30:32.131'!install	TheWorldMenu registerOpenCommand: {self title. {ScuGame . #open}}! !!ScuGame class methodsFor: 'world menu' stamp: 'Malte Swart 1/5/2012 16:24:57.635'!uninstall	TheWorldMenu unregisterOpenCommand: self title.! !!ScuGame class methodsFor: 'instance creation' stamp: 'dominik 2/4/2012 20:51:21.065'!make	 | ourPackage zip mczStream workingCopy version installCommand| 	ourPackage := 'Scu007'.	installCommand := ''. 	zip := ZipArchive new.	{ourPackage. #Animations. #'SVG-Morphic'} do: [:package |  		mczStream := RWBinaryOrTextStream on: (String new: 10000). 		workingCopy := MCWorkingCopy forPackage: (MCPackage new name: package). 		version := workingCopy newVersion. 		version fileOutOn: mczStream. 		(zip addString: mczStream contents as: package , '.mcz')   		desiredCompressionLevel: 0.		installCommand := installCommand, 'self fileInMonticelloZipVersionNamed: ''' , package , '.mcz''.', Character cr].	zip addString: installCommand as: 'install/preamble'. 	zip writeToFileNamed: ourPackage , '.sar'.! !!ScuGame class methodsFor: 'instance creation' stamp: 'Matthias Springer 2/6/2012 18:03:24.483'!newFrom: aConfiguration	^ super basicNew		configuration: aConfiguration;		initialize;		yourself! !!ScuGame class methodsFor: 'instance creation' stamp: 'Matthias Springer 2/10/2012 18:51'!open	^ self new		position: 200@80;		openInWorld;		yourself.! !!ScuGame class methodsFor: 'instance creation' stamp: 'Matthias Springer 2/10/2012 18:52'!openWithCheats	|game|	game := self open.	game configuration cheatsEnabled: true.	^ game! !!ScuGame class methodsFor: 'instance creation' stamp: 'Matthias Springer 1/31/2012 22:30:42.837'!unload	self uninstall.! !!ScuGame class methodsFor: 'accessing' stamp: 'Malte Swart 1/5/2012 16:33:25.598'!title	^ #'Space Clean-Up'! !Object subclass: #ScuGameState	instanceVariableNames: 'game'	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuGameState commentStamp: 'dominik 2/10/2012 14:49:12.71' prior: 0!ScuGameState is a generic ScuGame state.The State classes contains different methods to determine wheather items could move, the time should be count .!!ScuGameState methodsFor: 'actions' stamp: 'msw 2/9/2012 16:04:05.124'!activate! !!ScuGameState methodsFor: 'options' stamp: 'msw 2/9/2012 15:58:24.122'!allowMoving	^ false! !!ScuGameState methodsFor: 'options' stamp: 'msw 2/9/2012 19:18:37.464'!countTime	^ false! !!ScuGameState methodsFor: 'options' stamp: 'msw 2/9/2012 20:52:51.192'!isFinished	^ false! !!ScuGameState methodsFor: 'options' stamp: 'msw 2/9/2012 16:33:04.42'!togglePaused! !!ScuGameState methodsFor: 'accessing' stamp: 'msw 2/9/2012 16:07:17.145'!game	^ game! !!ScuGameState methodsFor: 'accessing' stamp: 'msw 2/9/2012 16:07:17.161'!game: anObject	game := anObject! !!ScuGameState methodsFor: 'render' stamp: 'msw 2/9/2012 16:15:47.886'!shouldDraw	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScuGameState class	instanceVariableNames: ''!!ScuGameState class methodsFor: 'instance creation' stamp: 'msw 2/9/2012 16:05:29.071'!newIn: aGame	| instance |	instance := self basicNew.	instance 		game: aGame;		initialize.	^ instance! !ScuGameState subclass: #ScuGameBuildState	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuGameBuildState commentStamp: 'msw 2/10/2012 12:28:43.141' prior: 0!A ScuGameBuildState is game state which is active while the ScuLevel is build with the builder.!!ScuGameBuildState methodsFor: 'actions' stamp: 'msw 2/10/2012 12:19:30.022'!activate	self game resources imageSize: self game configuration tileSize.	self game eventDispatcher: nil. "clear events"	self game		removeAllMorphs;		position: 150@50;		level: (ScuLevelDirector			newWithBuilder: self game configuration builder 			game: self game) construct.	self		drawControls;		drawStats;		drawLevel.	self game state: (ScuGamePausedState newIn: self game).! !!ScuGameBuildState methodsFor: 'render' stamp: 'msw 2/9/2012 16:26:03.884'!drawControls	| controls |	controls := ScuControls newIn: self game.	controls extent: 260@27;		position: self game bounds topLeft + ((self game extent x - 15)@(-25));		borderWidth: 2;		borderColor: Color white.	self game addMorph: controls.  ! !!ScuGameBuildState methodsFor: 'render' stamp: 'msw 2/9/2012 16:29:18.668'!drawLevel	self game level		borderWidth: 2;		borderColor: Color white;		extent: self game level extent + 4.	self game level submorphsDo: [:morph | morph position: morph bounds topLeft + 2].  	self game addMorph: self game level.	self game level position: self game bounds topLeft.! !!ScuGameBuildState methodsFor: 'render' stamp: 'dominik 2/10/2012 15:54:50.194'!drawStats	|stats|	stats := (ScuGameInformation newIn: self game).	stats extent: 142@(8*self game configuration tileSize y);		position: self game bounds topLeft + ((-140)@30);		borderWidth: 2;		borderColor: Color white.	self game addMorph: stats.	self game stats: stats.! !!ScuGameBuildState methodsFor: 'render' stamp: 'msw 2/9/2012 16:15:58.354'!shouldDraw	^ false! !ScuGameState subclass: #ScuGameConfigState	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuGameConfigState commentStamp: 'msw 2/10/2012 12:29:08.636' prior: 0!A ScuGameConfigState is active while the ScuConfigurationWindow is show and the user configurates the game.!!ScuGameConfigState methodsFor: 'actions' stamp: 'msw 2/9/2012 16:44:25.021'!activate	self game removeAllMorphs.	self drawConfigurationWindow.! !!ScuGameConfigState methodsFor: 'render' stamp: 'msw 2/9/2012 16:09:30.68'!drawConfigurationWindow	| morph |	morph := ScuConfigurationWindow newIn: self game.	morph position: self game bounds topLeft;		borderWidth: 2;		borderColor: Color white.  	self game addMorph: morph.    ! !ScuGameState subclass: #ScuGameOverState	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuGameOverState commentStamp: 'msw 2/10/2012 12:29:23.835' prior: 0!A ScuGameOverState is used, when the user has died.!!ScuGameOverState methodsFor: 'actions' stamp: 'msw 2/9/2012 21:14:22.151'!activate	| strings |	strings := self game configuration strings.	(UserDialogBoxMorph new 		title: (strings at: #lostTitle); 		label: (strings at: #lostText); 		addSelectedButton: (strings at: #levelAgainBtnText) value: [self game state: (ScuGameBuildState newIn: self game)];		addButton: (strings at: #anotherGameBtnText) value: [self game state: (ScuGameConfigState newIn: self game)];		addCancelButton: (strings at: #closeBtnText) value: [self game delete];		runModalIn: ActiveWorld forHand: ActiveHand at: nil) value.! !!ScuGameOverState methodsFor: 'options' stamp: 'msw 2/9/2012 20:53:04.148'!isFinished	^ true! !ScuGameState subclass: #ScuGamePausedState	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuGamePausedState commentStamp: 'msw 2/10/2012 12:30:36.131' prior: 0!A ScuGamePausedState is used when the game is builded but all changes are halt.!!ScuGamePausedState methodsFor: 'options' stamp: 'Matthias Springer 2/10/2012 15:49'!togglePaused	self game state: (ScuGameRunningState newIn: self game).! !ScuGameState subclass: #ScuGameRunningState	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuGameRunningState commentStamp: 'msw 2/10/2012 12:30:05.821' prior: 0!A ScuGameRunningState is used when the game/level is active.!!ScuGameRunningState methodsFor: 'options' stamp: 'msw 2/9/2012 15:59:23.547'!allowMoving 	^ true! !!ScuGameRunningState methodsFor: 'options' stamp: 'msw 2/9/2012 19:18:49.44'!countTime 	^ true! !!ScuGameRunningState methodsFor: 'options' stamp: 'Matthias Springer 2/10/2012 15:49'!togglePaused	self game state: (ScuGamePausedState newIn: self game).! !ScuGameState subclass: #ScuGameWonState	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuGameWonState commentStamp: 'msw 2/10/2012 12:29:38.494' prior: 0!A ScuGameWonState is used when the user has clean the level.!!ScuGameWonState methodsFor: 'actions' stamp: 'msw 2/9/2012 21:14:12.485'!activate	| strings |	strings := self game configuration strings.	(UserDialogBoxMorph new 		title: (strings at: #wonTitle); 		label: ((strings at: #wonText) format: {self game stats score});		addButton: (strings at: #levelAgainBtnText) value: [self game state: (ScuGameBuildState newIn: self game)];		addSelectedButton: (strings at: #anotherGameBtnText) value: [self game state: (ScuGameConfigState newIn: self game)];		addCancelButton: (strings at: #closeBtnText) value: [self game delete];		runModalIn: ActiveWorld forHand: ActiveHand at: nil) value.! !!ScuGameWonState methodsFor: 'options' stamp: 'msw 2/10/2012 11:44:54.2'!isFinished	^ true! !Object subclass: #ScuMonsterStrategy	instanceVariableNames: 'game monster directions'	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuMonsterStrategy commentStamp: 'Matthias Springer 2/5/2012 00:13:45.546' prior: 0!A ScuMonsterStrategy is an abstract monster strategy. Monster strategy determine, how monsters move. The strategy calculates the next moving direction. There is one monster strategy per monster.Instance Variables	directions:		All directions a monster can move. In diagonal mode, monsters can even move diagonally.	game:		Reference to the game.	monster:		Reference to the monster.!!ScuMonsterStrategy methodsFor: 'moving' stamp: 'Matthias Springer 2/3/2012 19:15:24.396'!canIEnter: aTile	^ aTile 		canIEnterWithPermissions: self monster enterPermissions		default: false! !!ScuMonsterStrategy methodsFor: 'moving' stamp: 'Matthias Springer 2/3/2012 19:09:08.024'!canIMove: aDirection	^ (self monster tileUnder neighborAt: aDirection) 		canIEnterWithPermissions: self monster enterPermissions 		default: false! !!ScuMonsterStrategy methodsFor: 'moving' stamp: 'Matthias Springer 1/8/2012 14:12:56.134'!move	self subclassResponsibility.! !!ScuMonsterStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:27:33.885'!directions	^ directions! !!ScuMonsterStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:50:30.111'!directions: anObject	directions := anObject.! !!ScuMonsterStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:27:31.463'!game	^ game! !!ScuMonsterStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:50:35.95'!game: anObject	game := anObject.! !!ScuMonsterStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 22:27:28.862'!monster	^ monster! !!ScuMonsterStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:50:48.343'!monster: anObject	monster := anObject.! !!ScuMonsterStrategy methodsFor: 'initialize-release' stamp: 'Matthias Springer 2/5/2012 12:52:50.954'!initialize 	self directions: (OrderedCollection newFrom: self game configuration directions).  ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScuMonsterStrategy class	instanceVariableNames: ''!!ScuMonsterStrategy class methodsFor: 'instance creation' stamp: 'Matthias Springer 2/6/2012 18:07:59.804'!newIn: aGame for: aMonster	^ self basicNew		game: aGame;		monster: aMonster;		initialize;		yourself! !ScuMonsterStrategy subclass: #ScuMonsterRandomStrategy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuMonsterRandomStrategy commentStamp: 'Matthias Springer 2/5/2012 00:14:06.012' prior: 0!A ScuMonsterRandomStrategy is moves the monster randomly.!!ScuMonsterRandomStrategy methodsFor: 'moving' stamp: 'Matthias Springer 2/9/2012 22:35:50.767'!move	^ self directions deepCopy shuffled 		detect: [:aDirection | self canIMove: aDirection] 		ifNone: nil! !ScuMonsterStrategy subclass: #ScuMonsterToPlayerStrategy	instanceVariableNames: 'shortestPath toPlayerProbability queue visitedTiles'	classVariableNames: ''	poolDictionaries: ''	category: 'Scu007-Core'!!ScuMonsterToPlayerStrategy commentStamp: 'Matthias Springer 2/10/2012 18:10' prior: 0!A ScuMonsterToPlayerStrategy moves the monster towards the player with a given probability, i.e. the monster either moves completely random or calculates the shortest path to the player and moves into that direction. The randomness was introduced to make the movement of the monster less predictable.Instance Variables	queue:		The breadth-first search queue, containing paths to be evaluated.	shortestPath:		Caches the shortest path to the player.	toPlayerProbability:		Determines, at which probability the monster moves random or towards the player.	visitedTiles:		Set of visited tiles for the breadth-first search not to get lost in cycles.Methods	bfsToPlayer:		Performs a breadth-first search to calculate the shortest path to the player (if there is a path). If no path was found the monster moves randomly.	directionToPlayer:				Prepares data structures for the breadth-first search and starts the algorithm.	bfsResultTo:		Takes the shortest path calculated by the bfs and returns only a fraction of it for caching purposes.	shortestPath:		Returns the cached path to the player or calculates a new one after some time. Caching is useful when there are more than 30 monsters on the game.!!ScuMonsterToPlayerStrategy methodsFor: 'moving' stamp: 'Matthias Springer 2/10/2012 18:03'!bfsAddToQueue: aTile from: aPath	|newPath|	(self canIEnter: aTile) ifTrue: [		newPath := aPath copy.		newPath addLast: aTile.		self queue addLast: newPath].! !!ScuMonsterToPlayerStrategy methodsFor: 'moving' stamp: 'Matthias Springer 2/10/2012 18:03'!bfsResultTo: aTile from: aPath	aPath addLast: aTile.	"Amount of caching: sqrt(path_length)"	^ aPath first: aPath size sqrt rounded.! !!ScuMonsterToPlayerStrategy methodsFor: 'moving' stamp: 'Matthias Springer 2/10/2012 18:02'!bfsToPlayer	|tile path|	[self queue isEmpty] whileFalse: [		path := self queue removeFirst. 		tile := path last.		(self visitedTiles includes: tile) ifFalse: [			self visitedTiles add: tile.			tile neighbors valuesDo: [:aTile | 				(aTile = self game mainPlayer tileUnder) 					ifTrue: [^ self bfsResultTo: aTile from: path].				self bfsAddToQueue: aTile from: path]]].	^ {nil}! !!ScuMonsterToPlayerStrategy methodsFor: 'moving' stamp: 'Matthias Springer 2/10/2012 18:13'!directionToPlayer	| path |	self visitedTiles: IdentitySet new.	self queue: OrderedCollection new.	self directions do: [:aDirection | (self canIMove: aDirection) ifTrue: [		path := OrderedCollection new.		path add: (monster tileUnder neighborAt: aDirection).		self queue addLast: path]].	^ self shortestPath! !!ScuMonsterToPlayerStrategy methodsFor: 'moving' stamp: 'Matthias Springer 2/10/2012 18:11'!move	|validDirections|	(self game random next < self toPlayerProbability)		ifTrue: [^ self directionToPlayer]		ifFalse: [			validDirections := (self directions select: [:dir | self canIMove: dir]).			validDirections ifNotEmpty: [^ validDirections atRandom]].	^ nil! !!ScuMonsterToPlayerStrategy methodsFor: 'moving' stamp: 'Matthias Springer 2/10/2012 17:44'!shortestPath	"Cache shortest path, useful for more than 20 monsters in the game."	shortestPath ifNil: [self shortestPath: OrderedCollection new].	shortestPath ifEmpty: [self shortestPath: self bfsToPlayer].	(self monster tileUnder neighbors values includes: shortestPath first) ifFalse: [			self shortestPath: self bfsToPlayer.			^ self directions atRandom].	^ self monster tileUnder neighbors keyAtValue: (shortestPath removeFirst)! !!ScuMonsterToPlayerStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 18:12'!queue	^ queue! !!ScuMonsterToPlayerStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 17:03'!queue: anObject	queue := anObject.! !!ScuMonsterToPlayerStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 2/10/2012 16:27'!shortestPath: anObject	shortestPath := anObject.! !!ScuMonsterToPlayerStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 2/3/2012 19:36:26.108'!toPlayerProbability	toPlayerProbability ifNil: [self toPlayerProbability: self game random next + 1 / 2].	^ toPlayerProbability! !!ScuMonsterToPlayerStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 1/31/2012 13:54:54.272'!toPlayerProbability: anObject	toPlayerProbability := anObject.! !!ScuMonsterToPlayerStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 2/3/2012 18:11:20.666'!visitedTiles	^ visitedTiles! !!ScuMonsterToPlayerStrategy methodsFor: 'accessing' stamp: 'Matthias Springer 2/3/2012 18:11:11.79'!visitedTiles: anObject	visitedTiles := anObject.! !ScuGame initialize!